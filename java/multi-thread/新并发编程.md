# 一、线程与进程、并行并发、同步异步概念

## 1、进程与进程

> 进程: 资源分配的最小单位
> 进程是线程的容器, 一个进程中包含多个线程, 真正执行任务的是线程

> 线程: 资源调度的最小单位

### 进程

- ==程序==由==指令==和==数据==组成，但是这些 **指令要运行，数据要读写**，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，==进程就是用来加载指令,管理内存,管理IO的==

- 当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程

- ==进程==就可以视为==程序==的一个==实例==，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）

### 线程

- 一个进程之内可以分为==多个线程==。
- ==一个线程==就是==一个指令流==，将指令流中的一条条指令以一定的顺序交给 CPU 执行
- Java 中，**线程作为资源的最小调度单位，进程作为资源分配的最小单位。** 在 windows 中进程是不活动的，只是作为线程的容器。

### 二者对比

- **进程**基本上==相互独立的==，而==线程存在于进程内，是进程的一个子集==

- **进程**拥有共享的资源，如**内存空间**等，供其内部的**线程共享**; 进程间通信较为复杂,同一台计算机的进程通信称为 IPC（Inter-process communication）
- ==不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP==

- **线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量**

- 线程更==轻量==，线程上下文切换成本一般上要比进程上下文切换低

## 2、 并行与并发

**并发:** 在单核CPU下, 一定是==并发执行==的, 也就是在同一个时间段内一起执行. 实际还是串行执行, CPU的时间片切换非常快, 给人一种同时运行的感觉。

**并行:** 在多核CPU下, 能真正意义上实现==并行执行==, 在同一个时刻, 多个线程同时执行; 比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在==并发==, 因为2个cpu也会同时切换不同的线程执行任务罢了

### 并发 (concurrent)

- ==微观串行, 宏观并行==

- 在==单核 cpu==下，==线程==实际还是==串行执行==的。操作系统中有一个组件叫做**任务调度器**，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于==cpu 在线程间（时间片很短）的切换非常快==，给人的 **感觉是同时运行**的 。一般会将这种==线程轮流使用 CPU==的做法称为==并发（concurrent）==

- 将==线程轮流使用cput==称为==并发(concurrent)==

![img](https://img-blog.csdnimg.cn/img_convert/466a3192acf5930dba4f58d28a99936a.png)



### 并行

==多核 cpu==下，每个核（core） 都可以调度运行线程，这时候线程可以是==并行==的，不同的线程同时使用不同的cpu在执行。

![1583408812725](https://img-blog.csdnimg.cn/img_convert/0c812484e0998d533c6212d80d059ff0.png)

### 二者对比

- 引用 Rob Pike 的一段描述：
  - ==并发（concurrent）==: 是同一时间应对（dealing with）多件事情的能力
  - ==并行（parallel）==: 是同一时间动手做（doing）多件事情的能力

例子

- 家庭主妇做饭、打扫卫生、给孩子喂奶，她**一个人轮流交替做这多件事**，这时就是==并发==
- 家庭主妇雇了个保姆，她们一起这些事，这时==既有并发，也有并行==（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）
- 雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，**互不干扰**，这时是 ==并行==

## 3、同步和异步

以==调用方==的角度讲

- 如果==需要等待结果返回才能继续运行==的话就是==同步==

- 如果==不需要等待==就是==异步==

### **1 设计**

- 多线程可以让方法执行变为==异步==的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这5秒cpu什么都做不了，其它代码都得暂停

### **2 结论**

- 比如在项目中，视频文件需要转换格式等操作比较==费时==，这时==开一个新线程处理视频转换==，**避免阻塞**主线程
- tomcat 的异步 servlet 也是类似的目的，==让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程==
- UI 程序中，开线程进行其他操作，避免阻塞 UI 线程

# 二、线程的创建 (==重点==)

## 1、创建一个线程（非主线程）

### 1、通过继承Thread创建线程

```java
public class CreateThread {
	public static void main(String[] args) {
		Thread myThread = new MyThread();
        // 启动线程
		myThread.start();
	}
}

class MyThread extends Thread {
	@Override
	public void run() {
		System.out.println("my thread running...");
	}
}
```

使用==继承方式==的好处是，在==run()方法==内获取当前线程==直接使用this==就可以了，无须使用Thread.currentThread()方法；不好的地方是==Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码==

### 2、使用Runnable配合Thread (推荐)

```java
public class Test2 {
	public static void main(String[] args) {
		//创建线程任务
		Runnable r = new Runnable() {
			@Override
			public void run() {
				System.out.println("Runnable running");
			}
		};
		//将Runnable对象传给Thread
		Thread t = new Thread(r);
		//启动线程
		t.start();
	}
}
```

或

```java
public class CreateThread2 {
   private static class MyRunnable implements Runnable {
      @Override
      public void run() {
         System.out.println("my runnable running...");
      }
   }

   public static void main(String[] args) {
      MyRunnable myRunnable = new MyRunnable();
      Thread thread = new Thread(myRunnable);
      thread.start();
   }
}
```

- 通过==实现Runnable接口==，并且实现==run()方法==。在创建线程时作为参数传入该类的实例即可

**方法二的简化：使用lambda表达式简化操作**

- **当一个接口带有==@FunctionalInterface注解==时，是可以使用lambda来简化操作的**
- 所以方法二中的代码可以被简化为

```java
public class Test2 {
	public static void main(String[] args) {
		//创建线程任务
		Runnable r = () -> {
            //直接写方法体即可
			System.out.println("Runnable running");
			System.out.println("Hello Thread");
		};
		//将Runnable对象传给Thread
		Thread t = new Thread(r);
		//启动线程
		t.start();
	}
}
```

#### 原理之 Thread 与 Runnable 的关系(d)

- 分析 ==Thread== 的源码，理清它与 Runnable 的关系

  > ***<u>源码分析</u>*** 补充

**小结**

- 继承Thread方式: 是把线程和任务合并在了一起
- 实现Runnable方式: 是把线程和任务分开了
- **用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活**

### 3、使用FutureTask与Thread结合

**使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）**

```java
public class FutureTaskTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //需要传入一个Callable对象
        FutureTask<Integer> task = new FutureTask<Integer>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                System.out.println("线程执行!");
                Thread.sleep(1000);
                return 100;
            }
        });

        Thread r1 = new Thread(task, "t2");
        r1.start();
        //获取线程中方法执行后的返回结果
        System.out.println(task.get());
    }
}
```

或者

```java
public class FutureTaskTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        FutureTask<String> futureTask = new FutureTask<>(new MyCall());
        Thread thread = new Thread(futureTask);
        thread.start();
        // 获得线程运行后的返回值
        System.out.println(futureTask.get());
    }
}

class MyCall implements Callable<String> {
    @Override
    public String call() throws Exception {
        return "hello world";
    }
}
```

### 4、使用线程池来创建线程

```java
/**
 * 创建线程的方式四：使用线程池
 *
 * 好处：
 * 1.提高响应速度（减少了创建新线程的时间）
 * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
 * 3.便于线程管理
 *      corePoolSize：核心池的大小
 *      maximumPoolSize：最大线程数
 *      keepAliveTime：线程没有任务时最多保持多长时间后会终止
 *
 *
 * 面试题：创建多线程有几种方式？四种！
 */

class NumberThread implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

public class ThreadPool {

    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        //设置线程池的属性
//        System.out.println(service.getClass());
//        service1.setCorePoolSize(15);
//        service1.setKeepAliveTime();


        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());//适合适用于Runnable
        service.execute(new NumberThread1());//适合适用于Runnable

//        service.submit(Callable callable);//适合使用于Callable
        //3.关闭连接池
        service.shutdown();
    }
}
```

### 总结

- 使用 **继承方式的好处是方便传参**，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果==使用Runnable方式==，则只能使用主线程里面被声明为final的变量。**不好的地方是Java不支持多继承**，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。**==前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以==**

- 开发中一般使用==线程池==的方式

![img](https://img-blog.csdnimg.cn/20201218110254483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)



# 三、线程运行原理 (==重点==)

## 1、虚拟机栈与栈帧

==虚拟机栈==描述的是==Java方法执行的内存模型==：**每个方法被执行的时候**都会同时创建一个==栈帧(stack frame)==用于存储==局部变量表、操作数栈、动态链接、方法出口==等信息，是属于**线程的私有的**。==当Java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧(在栈顶)，对应着当前正在执行的那个方法==

## 2、线程上下文切换（Thread Context Switch)

> 因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程

- **线程的 cpu 时间片用完**(每个线程轮流执行，看前面并行的概念)
- **垃圾回收**
- **有更高优先级的线程需要运行**
- 线程自己调用了 ==sleep==、==yield==、==wait==、==join==、==park==、==synchronized==、==lock== 等方法

 当==Thread Context Switch==发生时，需要由操作系统==保存当前线程的状态==，并==恢复另一个线程的状态==，Java 中对应的概念就是**程序计数器（Program Counter Register）**，它的作用是==记住下一条 jvm 指令的执行地址，是线程私有的==

- ==线程的状态==包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等

- Context Switch 频繁发生会==影响性能==

## 3、Thread的常见方法

![7f246.png)](https://img-blog.csdnimg.cn/20201218104837363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

### 3.1、调用start 与 run方法的区别

#### 调用start()方法

```java
public static void main(String[] args) {
    Thread thread = new Thread(){
      @Override
      public void run(){
          log.debug("我是一个新建的线程正在运行中");
          FileReader.read(fileName);
      }
    };
    thread.setName("新建线程");
    thread.start();
    log.debug("主线程");
}
```

- 输出：程序在==t1 线程运行==， ==run()==方法里面内容的调用是异步的代码

```java
11:59:40.711 [main] DEBUG com.concurrent.test.Test4 - 主线程
11:59:40.711 [新建线程] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中
11:59:40.732 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] start ...
11:59:40.735 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 3 ms
```

#### 调用run()方法

- 将上面代码的==thread.start();==改为 ==thread.run();==输出结果如下：程序仍在 main 线程运行， ==run()==方法里面内容的调用还是同步的

```java
12:03:46.711 [main] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中
12:03:46.727 [main] DEBUG com.concurrent.test.FileReader - read [test] start ...
12:03:46.729 [main] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 2 ms
12:03:46.730 [main] DEBUG com.concurrent.test.Test4 - 主线程
```

#### 小结

- 直接调用 ==run()== 是在主线程中执行了 ==run()==，**没有启动新的线程**
- 使用 ==start()== 是**启动新的线程**，通过新的线程间接执行 ==run()==方法中的代码

### 3.2、 sleep 与 yield

#### sleep方法

1. 调用 ==sleep()== 会让当前线程从 ==Running(运行状态)== 进入 ==Timed Waiting 状态（阻塞）==
2. 其它线程可以使用==interrupt 方法打断正在睡眠的线程==，那么被打断的线程这时就会抛出 ==InterruptedException异常==**【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】**
3. 睡眠结束后的线程未必会立刻得到执行 (需要分配到cpu时间片)
4. 建议用 ==TimeUnit== 的 ==sleep()== 代替 Thread 的 ==sleep()==来获得更好的可读性

#### yield方法

- **yield使cpu调用其它线程**，==但是cpu可能会再分配时间片给该线程==；==而sleep需要等过了休眠时间之后才有可能被分配cpu时间片==

### 3.3、线程优先级

- 线程==优先级==会==提示（hint）调度器优先调度该线程==，但它仅仅是一个提示，调度器可以忽略它, 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用

```java
thread1.setPriority(Thread.MAX_PRIORITY); //设置为优先级最高
```

### 3.4、 join方法

- 在==主线程==中调用==t1.join==，则==主线程==会==等待t1线程执行完之后==再==继续执行==

```java
private static void test1() throws InterruptedException {
    log.debug("开始");
    Thread t1 = new Thread(() -> {
        log.debug("开始");
        sleep(1);
        log.debug("结束");
        r = 10;
    },"t1");
    t1.start();
    // t1.join(); 
    // 这里如果不加t1.join(), 此时主线程不会等待t1线程给r赋值, 主线程直接就输出r=0结束了
    // 如果加上t1.join(), 此时主线程会等待到t1线程执行完才会继续执行.(同步), 此时r=10;
    log.debug("结果为:{}", r);
    log.debug("结束");
}
```

> 下图, 因为开辟了t1线程. 此时程序中有两个线程; main线程和t1线程; 此时在main线程中调用==t1.join==, 所以main线程只能==阻塞==等待t1线程执行完. ==t1线程在1s后将r=10==, t1线程执行完, 此时main线程才会接着执行
>
> ![1583483843354](https://img-blog.csdnimg.cn/img_convert/52ed0d839807dfa6768787cfe659fb9e.png)

### 3.5 interrupt 方法详解

**该方法用于打断 ==sleep，wait，join==的线程, 在阻塞期间cpu不会分配给时间片**

- 先了解一些==interrupt()方法==的相关知识：[博客地址](https://www.cnblogs.com/noteless/p/10372826.html#0)
- 如果==一个线程在在运行中被打断==，**打断标记会被置为true**
- 如果是打断==因sleep wait join方法而被阻塞的线程==，会将**打断标记置为false**

==sleep，wait，join==的线程，这几个方法都会让线程进入==阻塞状态==，以 sleep 为例

```java
public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println("sleep...");
            try {
                Thread.sleep(5000); // wait, join
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        t1.start();
        Thread.sleep(1000);
        System.out.println("iterrupt..");
        t1.interrupt();
        System.out.println("打断标记为: " + t1.isInterrupted()); // 如果是打断sleep,wait,join的线程, 即使打断了, 标记也为false
    }
```

```java
sleep...
iterrupt..
打断标记为: false
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.exampleone.demo.threadOne.bilibili.InterruptTest.lambda$main$0(InterruptTest.java:13)
	at java.lang.Thread.run(Thread.java:748)
```

**打断正常运行的线程**

- 打断正常运行的线程, 线程并不会暂停，只是调用方法==Thread.currentThread().isInterrupted()==的返回值为true，可以判断==Thread.currentThread().isInterrupted();==的值来手动停止线程

```java
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        while(true) {
            boolean interrupted = Thread.currentThread().isInterrupted();
            if(interrupted) {
                System.out.println("被打断了, 退出循环");
                break;
            }
        }
    }, "t1");
    t1.start();
    Thread.sleep(1000);
    System.out.println("interrupt");
    t1.interrupt();
    System.out.println("打断标记为: "+t1.isInterrupted());
}
```

```java
interrupt
被打断了, 退出循环
打断标记为: true
```

### 3.6、 终止模式之两阶段终止模式

> 当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来优雅的停止线程二。

Two Phase Termination，就是考虑在一个线程T1中如何优雅地终止另一个线程T2？**这里的优雅指**的是给T2线程一个处理其他事情的机会（如释放锁）。

两阶段终止模式

Two Phase Termination

在一个线程T1中如何“优雅’终止线程T2?这里的[**优雅**]指的是给T2一个料理后事的机会。

**1.错误思路**

- 使用线程对象的stop()方法停止线程

  - stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁

- 使用System. exit(int)方法停止线程

  - 目的仅是停止一个线程，但这种做法会让整个程序都停止

    

如下所示：那么线程的==isInterrupted()==方法可以==取得线程的打断标记==

- 如果线程在睡眠==sleep==期间被打断，**打断标记是不会变的**，为==false==，但是==sleep==期间被打断会抛出异常，我们据此**手动设置**打断标记为==true==；
- 如果是在==程序正常运行期间被打断==的，那么打断标记就被自动设置为==true==。处理好这两种情况那我们就可以放心地来料理后事啦！

下图①就是正常运行打断, ②是在睡眠中被打断

![打断](https://img-blog.csdnimg.cn/img_convert/889b421e38b1d734bb96cbf20feb4664.png)

代码实现如下：

```java
public class Test7 {
	public static void main(String[] args) throws InterruptedException {
		Monitor monitor = new Monitor();
		monitor.start();
		Thread.sleep(3500);
		monitor.stop();
	}
}

class Monitor {

	Thread monitor;

	/**
	 * 启动监控器线程
	 */
	public void start() {
		//设置线控器线程，用于监控线程状态
		monitor = new Thread() {
			@Override
			public void run() {
				//开始不停的监控
				while (true) {
                    //判断当前线程是否被打断了
					if(Thread.currentThread().isInterrupted()) {
						System.out.println("处理后续任务");
                        //终止线程执行
						break;
					}
					System.out.println("监控器运行中...");
					try {
						//线程休眠
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						e.printStackTrace();
						//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记
						Thread.currentThread().interrupt();
					}
				}
			}
		};
		monitor.start();
	}

	/**
	 * 	用于停止监控器线程
	 */
	public void stop() {
		//打断线程
		monitor.interrupt();
	}
}

```



### 3.7、sleep，yiled，wait，join 对比

> 补充：
>
> - sleep，join，yield，interrupted是Thread类中的方法
> - wait/notify是object中的方法
> - sleep 不释放锁、释放cpu
> - join 释放锁、抢占cpu
> - yiled 不释放锁、释放cpu
> - wait 释放锁、释放cpu

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201218122903649.png)

> ==关于join释放锁==

释放哪个对象的锁呢？

难道是释放父线程所持有的所有对象的锁？

其实如果看了源码，很容易明白释放的是运行（这个地方可能有些歧义，但是我也不知道怎么说最好）join()方法的那个线程对象的锁，不过这些都是后话，我们且往下看；

```java
/**
 * @Description: 验证join释放锁
 */
public class JoinLockTest {


    public static void main(String[] args) {
        Object oo = new Object();

        Thread thread1 = new MyThread("thread1 -- ", oo);
        thread1.setName("myThread");
        thread1.start();

        synchronized (oo) {
            for (int i = 0; i < 100; i++) {
                if (i == 10) {
                    try {
                        thread1.join();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName() + " -- " + i);
            }
        }
    }
}

class MyThread extends Thread {

    private String name;
    private Object oo;

    public MyThread(String name, Object oo) {
        this.name = name;
        this.oo = oo;
    }

    @Override
    public void run() {
        synchronized (oo) {
            for (int i = 0; i < 100; i++) {
                System.out.println(name + i);
            }
        }
    }

}
```

![image-20210623175512625](/Users/qianwei/Library/Application Support/typora-user-images/image-20210623175512625.png)

如图所示运行到9就卡住了，先使用jps找到出问题程序的进程号，jstack pid 来查看线程堆栈，结果如下

```java
"myThread" #13 prio=5 os_prio=31 tid=0x00007fa86e08d800 nid=0xa303 waiting for monitor entry [0x000070000338a000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.exampleone.demo.threadOne.bilibili.MyThread.run(JoinLockTest.java:49)
        - waiting to lock <0x000000076b120518> (a java.lang.Object)
     
"main" #1 prio=5 os_prio=31 tid=0x00007fa86e009000 nid=0xa03 in Object.wait() [0x0000700001c42000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x000000076b120528> (a com.exampleone.demo.threadOne.bilibili.MyThread)
        at java.lang.Thread.join(Thread.java:1252)
        - locked <0x000000076b120528> (a com.exampleone.demo.threadOne.bilibili.MyThread)
        at java.lang.Thread.join(Thread.java:1326)
        at com.exampleone.demo.threadOne.bilibili.JoinLockTest.main(JoinLockTest.java:25)
        - locked <0x000000076b120518> (a java.lang.Object)
```

myThread 在BLOCKED，main在WAITING。myThread 在等待锁0x000000076b120518。main在持有锁0x000000076b120518。

这时候我们就回到了最初的问题，到底join()的时候释放的是谁的锁，通过查看join()方法的源码，很容易看到，其实调用的是 this.wait(),也就是说释放的是myThread 这个对象的锁

接着我们来用下面的代码证实一下我们得出的结论

```java
/**
 * @Description: 验证join释放锁
 */
public class JoinLockTest {


    public static void main(String[] args) {
        Object oo = new Object();

        Thread thread1 = new MyThread("thread1 -- ", oo);
        thread1.setName("myThread");
        thread1.start();

        synchronized (thread1) {
            for (int i = 0; i < 100; i++) {
                if (i == 10) {
                    try {
                        thread1.join();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName() + " -- " + i);
            }
        }
    }
}

class MyThread extends Thread {

    private String name;
    private Object oo;

    public MyThread(String name, Object oo) {
        this.name = name;
        this.oo = oo;
    }

    @Override
    public void run() {
        synchronized (oo) {
            for (int i = 0; i < 100; i++) {
                System.out.println(name + i);
            }
        }
    }

}
```

程序正常运行结束

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623223933011.png" alt="image-20210623223933011" style="zoom:50%;" />

### 3.8、 守护线程

- 当==Java进程==中有==多个线程==在执行时，**只有当所有非守护线程都执行完毕后，Java进程才会结束**。但当非守护线程全部执行完毕后，==守护线程无论是否执行完毕，也会一同结束。==

> **注意:**
>
> - ==垃圾回收器线程==就是一种守护线程
> - Tomcat 中的 ==Acceptor 和 Poller 线程==都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等

# 四、 线程状态

### 五种状态

-  在==操作系统==的层面上

![1583507073055](https://img-blog.csdnimg.cn/img_convert/b1754631b4dfc3b98fd5375100a3fe34.png)

1. **==初始状态==**，仅仅是在语言层面上**创建了线程对象**，即==Thead thread = new Thead();==，还未与操作系统线程关联
2. **==可运行状态==**，也称==就绪状态==，指该线程已经被创建，与操作系统相关联，**等待cpu给它分配时间片就可运行**
3. **==运行状态==**，**指线程获取了CPU时间片，正在运行**
   - 当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换
4. **==阻塞状态==**
   1. 如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】
   2. 等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】
   3. ==与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片==
5. **==终止状态==**，**表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态**

### 六种状态

-  这是从**==Java API==** 层面来描述的

> 根据==Thread.State 枚举，分为六种状态==

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210129171228140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

==**新建状态、运行状态(就绪状态, 运行中状态)、阻塞状态、等待状态、定时等待状态、终止状态**==

- **==NEW (新建状态)==** 线程刚被创建，但是还没有调用 start() 方法
- **==RUNNABLE (运行状态)==** 当调用了 ==start() 方法之后==，注意，Java API 层面的==RUNNABLE 状态涵盖了操作系统层面的 【就绪状态】、【运行中状态】和【阻塞状态】==（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）
- **==BLOCKED (阻塞状态)== ， ==WAITING (等待状态)== ， ==TIMED_WAITING(定时等待状态)==** 都是 Java API 层面对【阻塞状态】的细分，如**sleep**就位**TIMED_WAITING**， **join**为**WAITING**状态。后面会在状态转换一节详述。
- **==TERMINATED (结束状态)==** 当线程代码运行结束

```java
/**
 * @Description: 线程状态
 */
@Slf4j(topic = "c.ThreadStateTest")
public class ThreadStateTest {

    public static void main(String[] args) throws IOException {
        Thread t1 = new Thread("t1") {	// new 状态
            @Override
            public void run() {
                log.debug("running...");
            }
        };

        Thread t2 = new Thread("t2") {
            @Override
            public void run() {
                while(true) { // runnable 状态

                }
            }
        };
        t2.start();

        Thread t3 = new Thread("t3") {
            @Override
            public void run() {
                log.debug("running...");
            }
        };
        t3.start();

        Thread t4 = new Thread("t4") {
            @Override
            public void run() {
                synchronized (ThreadStateTest.class) {
                    try {
                        Thread.sleep(1000000); // timed_waiting 显示阻塞状态
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t4.start();

        Thread t5 = new Thread("t5") {
            @Override
            public void run() {
                try {
                    t2.join(); // waiting 状态
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t5.start();

        Thread t6 = new Thread("t6") {
            @Override
            public void run() {
                synchronized (ThreadStateTest.class) { // blocked 状态
                    try {
                        Thread.sleep(1000000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t6.start();

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("t1 state {}", t1.getState());
        log.debug("t2 state {}", t2.getState());
        log.debug("t3 state {}", t3.getState());
        log.debug("t4 state {}", t4.getState());
        log.debug("t5 state {}", t5.getState());
        log.debug("t6 state {}", t6.getState());
    }
}
```

# 五、 线程安全问题 (==重点==)

> Java3y : [多线程基础](https://mp.weixin.qq.com/s/TPZ2NBFy6niBq7b6FOJp4Q)

## **1、小故事**

老王(操作系统)有一个功能强大的算盘(CPU)，现在想把它租出去，赚一点外快

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623230550139.png" alt="image-20210623230550139" style="zoom: 50%;" />

- 小南、小女(线程)来使用这个算盘来进行一些计算，并按照时间给老王支付费用
- 但小南不能一天24小时使用算盘，他经常要小憩一会(sleep)，又或是去吃饭上厕所(阻塞 io 操作)，有 时还需要一根烟，没烟时思路全无(wait)这些情况统称为(阻塞)

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623230658111.png" alt="image-20210623230658111" style="zoom:50%;" />

- 在这些时候，算盘没利用起来(不能收钱了)，老王觉得有点不划算

- 另外，小女也想用用算盘，如果总是小南占着算盘，让小女觉得不公平

- 于是，老王灵机一动，想了个办法 [ 让他们每人用一会，轮流使用算盘 ] 

- 这样，当小南阻塞的时候，算盘可以分给小女使用，不会浪费，反之亦然 
- 最近执行的计算比较复杂，需要存储一些中间结果，而学生们的脑容量(工作内存)不够，所以老王申请了 一个笔记本(主存)，把一些中间结果先记在本上
- 计算流程是这样的

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623230805402.png" alt="image-20210623230805402" style="zoom:50%;" />

- 但是由于分时系统，有一天还是发生了事故

- 小南刚读取了初始值 0 做了个 +1 运算，还没来得及写回结果

- 老王说 [ 小南，你的时间到了，该别人了，记住结果走吧 ]，于是小南念叨着 [ 结果是1，结果是1...] 不甘心地 到一边待着去了(上下文切换)

- 老王说 [ 小女，该你了 ]，小女看到了笔记本上还写着 0 做了一个 -1 运算，将结果 -1 写入笔记本 
- 这时小女的时间也用完了，老王又叫醒了小南:[小南，把你上次的题目算完吧]，小南将他脑海中的结果 1 写 入了笔记本

 <img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623230957897.png" alt="image-20210623230957897" style="zoom: 50%;" />

- 小南和小女都觉得自己没做错，但笔记本里的结果是 1 而不是 0

## 2、**Java 的体现**

- 线程出现问题的==根本原因==是因为==线程上下文切换==，导致==线程里的指令没有执行完就切换执行其它线程==了，下面举一个例子

两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗?

```java
public class Test {
	static int count = 0;
	public static void main(String[] args) throws InterruptedException {
	    Thread t1 = new Thread(()->{
	        for (int i = 1; i < 5000; i++){
	            count++;
	        }
	    });
	    Thread t2 =new Thread(()->{
	        for (int i = 1; i < 5000; i++){
	            count--;
	        }
	    });
	    t1.start();
	    t2.start();
	    t1.join(); // 主线程等待t1线程执行完
	    t2.join(); // 主线程等待t2线程执行完
	    
	    // main线程只有等待t1, t2线程都执行完之后, 才能打印count, 否则main线程不会等待t1,t2
	    // 直接就打印count的值为0
	    log.debug("count的值是{}",count);
	}
}

// 打印: 并不是我们期望的0值, 为什么呢? 看下文分析
09:42:42.921 guizy.ThreadLocalDemo [main] - count的值是511 
```

>  **Java 中对静态变量的自增/自减并不是原子操作**，要彻底理 解，必须从**字节码**来进行分析

从==字节码的层面==进行分析：

- 因为在Java中对==静态变量==的 **==自增/自减==** 并不是==原子操作==

例如对于 i++ 而言(i 为静态变量)，实际会产生如下的 JVM 字节码指令:

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623234333828.png" alt="image-20210623234333828" style="zoom:50%;" />

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623234300531.png" alt="image-20210623234300531" style="zoom: 50%;" />

```java
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
iadd // 自增
putstatic i // 将修改后的值存入静态变量i
    
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
isub // 自减
putstatic i // 将修改后的值存入静态变量i
```

- 可以看到==count++== 和 ==count--== 操作实际都是需要这个==4个指令==完成的，那么这里问题就来了！==Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：==

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623234509617.png" alt="image-20210623234509617" style="zoom:50%;" />

如果是单线程以上 8 行代码是**顺序执行**(不会交错)没有问题:

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623234607176.png" alt="image-20210623234607176" style="zoom:50%;" />

- **出现负数的情况：一个线程==没有完成==一次==完整的自增/自减==(多个指令) 的操作, 就被别的线程进行操作, 此时就会出现==线程安全==问题**

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623234656301.png" alt="image-20210623234656301" style="zoom:50%;" />

> 上图解释:
>
> - 首先==线程2==去==静态变量中读取到值0==, 准备==常数1==, 完成==isub减法,变-1==操作, 正常还剩下一个==putstatic i写入-1==的过程; 最后的指令没有执行, 就被==线程1==抢去了cpu的执行权;
> - 此时线程1进行操作, 读取静态变量0, 准备常数1, iadd加法, i=1, 此时将==putstatic i写入 1==; 当==线程2==重新获取到cpu的执行权时, 它通过自身的==程序计数器==知道自己该执行==putstatic 写入-1==了; 此时它就直接将结果写为-1

- **出现正数的情况**：同上类似; ==主要就是因为线程的++/--操作不是一个原子操作, 在执行4条指令期间被其他线程抢夺cpu==

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623234928329.png" alt="image-20210623234928329" style="zoom:50%;" />

## 3、临界区

- 一个程序运行多线程本身是没有问题的
- 问题出现在==多个线程共享资源(临界资源)==的时候
  - 多个线程同时对共享资源进行==读操作==本身也没有问题 - **对读操作没问题**
  - ==问题出现在对对共享资源同时进行读写操作时就有问题了== - **同时读写操作有问题**

- 先定义一个叫做==临界区==的概念：一段代码内如果**存在对共享资源的多线程读写操作**，那么称这段代码为==临界区==; 共享资源也成为==临界资源==

```java
static int counter = 0;
static void increment() // 临界区
{
counter++; }
static void decrement() // 临界区
{
counter--; }
```

## 4、竞态条件

- 多个线程在==临界区==执行，那么由于**代码指令的执行不确定而导致的结果问题**，称为==竞态条件==

##  5、synchronized 解决方案

- ==为了避免临界区中的竞态条件发生==，由多种手段可以达到
  - **阻塞式解决方案：** ==synchronized , Lock (ReentrantLock)==
  - **非阻塞式解决方案：** ==原子变量 (CAS)==

现在讨论使用==synchronized==来进行解决，即俗称的==对象锁==，它采用==互斥==的方式**让==同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住==，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，==不用担心线程上下文切换==**

> ==注意:== 虽然Java 中==互斥==和==同步==都可以采用 ==synchronized 关键字==来完成，但它们还是有区别的：
>
> - 互斥是保证临界区的竞态条件发生，**同一时刻只能有一个线程执行临界区的代码**
> - 同步是由于线程执行的先后，**顺序不同但是需要一个线程等待其它线程运行到某个点**。

### synchronized语法

```java
synchronized(对象) { // 线程1获得锁， 那么线程2的状态是(blocked)
 	临界区
}
```

- 上面的实例程序使用==synchronized==后如下，计算出的结果是正确！

```java
static int counter = 0;
static final Object room = new Object();
public static void main(String[] args) throws InterruptedException {
     Thread t1 = new Thread(() -> {
         for (int i = 0; i < 5000; i++) {
         	 // 对临界资源(共享资源的操作) 进行 加锁
             synchronized (room) {
             counter++;
        	}
 		}
 	}, "t1");
     Thread t2 = new Thread(() -> {
         for (int i = 0; i < 5000; i++) {
             synchronized (room) {
             counter--;
         }
     }
     }, "t2");
     t1.start();
     t2.start();
     t1.join();
     t2.join();
     log.debug("{}",counter);
}

09:56:24.210 guizy.ThreadLocalDemo [main] - count的值是0
```

### synchronized原理

- ==synchronized==实际上==利用对象锁==保证了==临界区代码的原子性==，临界区内的代码在外界看来是不可分割的，**不会被线程切换所打断**

**小故事**

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623235735028.png" alt="image-20210623235735028" style="zoom:50%;" />

你可以做这样的类比:

- synchronized(对象) 中的对象，可以想象为一个房间(room)，有唯一入口(门)房间只能一次进入一人 进行计算，线程 t1，t2 想象成两个人

- 当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++ 代码

- 这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切 换，阻塞住了

- 这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外(不要错误理解为锁住了对象就能一直执行下去哦)， 这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才 能开门进入

- 当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥 匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count-- 代码

**用图来表示**

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210623235919020.png" alt="image-20210623235919020" style="zoom:50%;" />

**思考:**

- 如果把==synchronized(obj)==放在==for循环==的外面, 如何理解?
  - for循环也是一个原子操作, 表现出原子性

- 如果t1 ==synchronized(obj1)== 而 t2 ==synchronized(obj2)==会怎么运行?
  - 因为t1, t2拿到不是同一把==对象锁==, 所以他们仍然会发现==安全问题== – 必须要是同一把对象锁
- 如果t1 ==synchronized(obj)== 而 t2 没有加会怎么样 ?
  - 因为t2没有加锁, 所以t2, 不需要获取t1的锁, 直接就可以执行下面的代码, 仍然会出现==安全问题==

**小总结:**

- 当多个线程对==临界资源==进行==写操作==的时候, 此时会造成==线程安全==问题, 如果使用==synchronized==关键字, ==对象锁==一定要是多个线程==共有==的, 才能避免==竞态条件==的发生。

### synchronized 加在方法上

- 加在==实例方法==上, 锁对象就是对象实例

```java
public class Demo {
	//在方法上加上synchronized关键字
	public synchronized void test() {
	
	}
	//等价于
	public void test() {
		synchronized(this) {
		
		}
	}
}
```

- 加在==静态方法==上, 锁对象就是当前类的Class实例

```java
public class Demo {
	//在静态方法上加上synchronized关键字
	public synchronized static void test() {
	
	}
	//等价于
	public void test() {
		synchronized(Demo.class) {
		
		}
	}
}
```

==**面向对象的改进**==

```java
class Room {
    int value = 0;

    public void increment() {
        synchronized (this) {
            value++;
        }
    }

    public void decrement() {
        synchronized (this) {
            value--;
        }
    }

    public int get() {
        synchronized (this) {
            return value;
        }
    }
}

@Slf4j
public class Test1 {
    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(() -> {
            for (int j = 0; j < 5000; j++) {
                room.increment()
            }
        }, "t1");

        Thread t2 = new Thread(() -> {
            for (int j = 0; j < 5000; j++) {
                room.decrement();
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("count: {}", room.get());
    }
}
```



### 线程八锁案例分析

- 其实就是考察==synchronized 锁住的是哪个对象==, 如果锁住的是==同一对象==, 就不会出现==线程安全==问题

1、**锁住同一个对象都是this（e1对象），结果为：1,2或者2,1**

```java
package com.exampleone.demo.threadOne.bilibili;

import lombok.extern.slf4j.Slf4j;

/**
 * @Description: 不会出现安全问题, 打印结果顺序为: 1/2 或 2/1
 */
@Slf4j(topic = "c.EightLockTest")
public class EightLockTest {
        // 锁对象就是this, 也就是e1
        public synchronized void a() {
            log.debug("1");
        }

        // 锁对象也是this, e1
        public synchronized void b() {
            log.debug("2");
        }

        public static void main(String[] args) {
            EightLockTest e1 = new EightLockTest();
            new Thread(() -> e1.a()).start();
            new Thread(() -> e1.b()).start();
        }
    }

```

2、**锁住同一个对象都是this（e1对象），结果为：1s后1,2 || 2,1s后1**

```java
/**
 * @Description: 不会出现安全问题, 打印结果顺序为: 1s后1,2 || 2,1s后1
 */
@Slf4j(topic = "guizy.EightLockTest")
public class EightLockTest {
    // 锁对象就是this, 也就是e1
    public synchronized void a() {
        Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象也是this, e1
    public synchronized void b() {
        log.debug("2");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        new Thread(() -> e1.b()).start();
        new Thread(() -> e1.a()).start();
    }
}
```

3、**a，b锁住同一个对象都是this（e1对象），c没有上锁。结果为：3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1**

```java
/**
 * Description: 会出现安全问题, 因为前两个线程, 执行run方法时, 都对相同的对象加锁;
 *              而第三个线程,调用的方法c, 并没有加锁, 所以它可以同前两个线程并行执行;
 *  打印结果顺序为: 分析: 因为线程3和线程1,2肯定是并行执行的, 所以有以下情况
 *               3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1
 *               至于 1,3,2的情况是不会发生的, 可以先调用到1,但需要sleep一秒.3肯定先执行了
 *
 */
public class EightLockTest {
    // 锁对象就是this, 也就是e1
    public synchronized void a() throws InterruptedException {
        Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象也是this, e1
    public synchronized void b() {
        log.debug("2");
    }

    public void c() {
        log.debug("3");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        new Thread(() -> {
            try {
                e1.a();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        new Thread(() -> e1.b()).start();
        new Thread(() -> e1.c()).start();
    }
}
```

4**、a锁住对象this（n1对象），b锁住对象this（n2对象），不互斥。结果为：2,1s后1**

```java
/**
 * Description: 会出现安全问题, 线程1的锁对象为e1, 线程2的锁对象为e2. 所以他们会同一时刻执行1,2
 */
public class EightLockTest {
    // 锁对象是e1
    public synchronized void a() {
    		Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象是e2
    public synchronized void b() {
        log.debug("2");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        EightLockTest e2 = new EightLockTest();
        new Thread(() -> e1.a()).start();
        new Thread(() -> e2.b()).start();
    }
}
```

5、**a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1**

```java
/**
 * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥
 *              结果: 2,1s后1
 */
public class EightLockTest {
    // 锁对象是EightLockTest.class类对象
    public static synchronized void a() {
        Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象是e2
    public synchronized void b() {
        log.debug("2");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        new Thread(() -> e1.a()).start();
        new Thread(() -> e1.b()).start();
    }
}
```

6、**a,b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2**

```java
/**
 * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥
 *              结果: 2,1s后1 || 1s后1,2
 */
public class EightLockTest {
    // 锁对象是EightLockTest.class类对象
    public static synchronized void a() {
        Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象是EightLockTest.class类对象
    public static synchronized void b() {
        log.debug("2");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        new Thread(() -> e1.a()).start();
        new Thread(() -> e1.b()).start();
    }
}
```

7、**a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1**

```java
/**
 * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥
 *              结果: 2,1s后1
 */
public class EightLockTest {
    // 锁对象是EightLockTest.class类对象
    public static synchronized void a() {
        Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象是this,e2对象
    public synchronized void b() {
        log.debug("2");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        EightLockTest e2 = new EightLockTest();
        new Thread(() -> e1.a()).start();
        new Thread(() -> e2.b()).start();
    }
}
```

8、**a,b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2**

```java
/**
 * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥
 *              结果: 2,1s后1 || 1s后1,2
 */
public class EightLockTest {
    // 锁对象是EightLockTest.class类对象
    public static synchronized void a() {
        Thread.sleep(1000);
        log.debug("1");
    }

    // 锁对象是EightLockTest.class类对象
    public static synchronized void b() {
        log.debug("2");
    }

    public static void main(String[] args) {
        EightLockTest e1 = new EightLockTest();
        EightLockTest e2 = new EightLockTest();
        new Thread(() -> e1.a()).start();
        new Thread(() -> e2.b()).start();
    }
}
```

## 6、 变量的线程安全分析

[成员变量、类变量、局部变量的区别]: https://blog.csdn.net/du_minchao/article/details/48881637

> ==**成员变量和局部变量的区别**==
>
> 成员变量：
>   1、成员变量定义在类中，在整个类中都可以被访问。
>
> 	2、成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。
>
> ​     3、成员变量有默认初始化值。
>
> 局部变量：
>
> 	1、局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。
> 		
> 	2、局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。
> 		
> 	3、局部变量没有默认初始化值 
>
> 在使用变量时需要遵循的原则为：**就近原则**
>
> 首先在局部范围找，有就使用；接着在成员位置找。

### 1、 成员变量和静态变量的线程安全分析 (==重要==)

- ==如果变量没有在线程间共享，那么变量是安全的==
- 如果变量在线程间共享
  - 如果只有==读操作==，则==线程安全==
  - 如果有==读写操作==，则这段代码是==临界区==，==需要考虑线程安全==

### 2、 局部变量线程安全分析 (==重要==)

- 局部变量==【局部变量被初始化为基本数据类型】是安全的==
- 但局部变量引用的对象则未必 （要看该对象是否被共享且被执行了读写操作）
  - 如果==该对象没有逃离方法的作用范围==，它是==线程安全的==
  - 如果==该对象逃离方法的作用范围==，需要==考虑线程安全==

### 3、线程安全的情况 (==重要==)

- **局部变量表是存在于栈帧中**, 而虚拟机栈中又包括很多栈帧, **虚拟机栈是线程私有的**;
- 局部变量【局部变量被初始化为基本数据类型】是安全的，示例如下

```java
public static void test1() {
     int i = 10;
     i++;
}
```

- 每个线程调用 test1() 方法时局部变量 i，会在==每个线程的栈帧内存中被创建多份，因此不存在共享==

```java
public static void test1();
 descriptor: ()V
 flags: ACC_PUBLIC, ACC_STATIC
 Code:
	 stack=1, locals=1, args_size=0
	 0: bipush 10
	 2: istore_0
	 3: iinc 0, 1
	 6: return
	 LineNumberTable:
	 line 10: 0
	 line 11: 3
	 line 12: 6
	 LocalVariableTable:
	 Start Length Slot Name Signature
	 3			 4		 0 		i			 I
```

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210624002507870.png" alt="image-20210624002507870" style="zoom: 50%;" />

### 4、线程不安全的情况

- 成员变量示例

> 循环创建了100个线程, 在线程体里面都调用了==method1==方法, 在method1方法中又循环调用了100次==method2,method3==方法。方法2,3都使用到了成员变量==arrayList==, 此时的问题就是: ==1个线程它会循环调用100次方法2和3==, 一共有100个线程, 此时100个线程操作的==共享资源==就是==arrayList==成员变量 , 而且还进行了==读写==操作. 必然会造成==线程不安全的问题==

```java
/**
 * @Description: 成员变量线程不安全示例
 */
@Slf4j(topic = "c.test")
public class Test10 {

    public static void main(String[] args) {
        UnsafeTest unsafeTest = new UnsafeTest();
        for (int i =0;i<100;i++){
            new Thread(()->{
                unsafeTest.method1();
            },"线程"+i).start();
        }
    }
}

class UnsafeTest{
    ArrayList<String> arrayList = new ArrayList<>();
    public void method1(){
        for (int i = 0; i < 100; i++) {
          	//{ 临界区, 会产生竞态条件
            method2();
            method3();
          // } 临界区
        }
    }
    private void method2() {
        arrayList.add("1");
    }
    private void method3() {
        arrayList.remove(0);
    }
}

```

其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错:

```java
Exception in thread "线程0" java.lang.IndexOutOfBoundsException: Index: 0, Size: 1
	at java.util.ArrayList.rangeCheck(ArrayList.java:657)
	at java.util.ArrayList.remove(ArrayList.java:496)
	at com.exampleone.demo.threadOne.bilibili.UnsafeTest.method3(Test10.java:37)
	at com.exampleone.demo.threadOne.bilibili.UnsafeTest.method1(Test10.java:30)
	at com.exampleone.demo.threadOne.bilibili.Test10.lambda$main$0(Test10.java:19)
	at java.lang.Thread.run(Thread.java:748)
Exception in thread "线程27" java.lang.IndexOutOfBoundsException: Index: 0, Size: -1
	at java.util.ArrayList.rangeCheck(ArrayList.java:657)
	at java.util.ArrayList.remove(ArrayList.java:496)
	at com.exampleone.demo.threadOne.bilibili.UnsafeTest.method3(Test10.java:37)
	at com.exampleone.demo.threadOne.bilibili.UnsafeTest.method1(Test10.java:30)
	at com.exampleone.demo.threadOne.bilibili.Test10.lambda$main$0(Test10.java:19)
	at java.lang.Thread.run(Thread.java:748)
Exception in thread "线程26" java.lang.ArrayIndexOutOfBoundsException: -1
	at java.util.ArrayList.remove(ArrayList.java:505)
	at com.exampleone.demo.threadOne.bilibili.UnsafeTest.method3(Test10.java:37)
	at com.exampleone.demo.threadOne.bilibili.UnsafeTest.method1(Test10.java:30)
	at com.exampleone.demo.threadOne.bilibili.Test10.lambda$main$0(Test10.java:19)
	at java.lang.Thread.run(Thread.java:748)
Exception in thread "线程28" java.lang.ArrayIndexOutOfBoundsException: -1
	at java.util.ArrayList.add(ArrayList.java:463)
	at com.exampleone.demo.threadOne.bilibili.UnsafeTest.method2(Test10.java:34)
	at com.exampleone.demo.threadOne.bilibili.UnsafeTest.method1(Test10.java:29)
	at com.exampleone.demo.threadOne.bilibili.Test10.lambda$main$0(Test10.java:19)
	at java.lang.Thread.run(Thread.java:748)

Process finished with exit code 0
```

**分析:**

- 无论==哪个线程中的 method2 和 method3 引用的都是同一个对象中的 list 成员变量==

- 一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：
  - 第一步: 在 ==arrayList[size]==的位置存放此元素
  - 第二步: ==size++==

- 在==单线程==运行的情况下，如果 size = 0，添加一个元素后，此元素在位置 0，而且 size=1；==(没问题)==

- 在==多线程==情况下，比如有两个线程，==线程 A 先将元素存放在位置 0。但是此时 CPU 进行上下文切换 (线程A还没来得及size++)==，**线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于0** （注意，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，==都增加 size 的值==。

- 那好，现在我们来看看 ==ArrayList== 的情况，==元素实际上只有一个，存放在位置 0==，而 ==size 却等于 2==。这就是“线程不安全”了。

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210624005638032.png" alt="image-20210624005638032" style="zoom:50%;" /><img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210624005707149.png" alt="image-20210624005707149" style="zoom:50%;" />

**解决方法**

- 可以将==list==修改成==局部变量==，list 是局部变量，每个线程调用时会创建其不同实例，没有共享。局部变量存放在栈帧中, 栈帧又存放在==虚拟机栈==中, **虚拟机栈是作为线程私有的;**

- 而 method2、 method3  的参数是从 method1 中传递过来的，与 method1 中引用同一个对象

- 因为method1方法, 将==arrayList==传给method2,method3方法, 此时他们三个方法==共享这同一个arrayList==, 此时**不会被其他线程访问到**, 所以不会出现==线程安全问题==, 因为==这三个方法使用的同一个线程==。

- 在外部, 创建了100个线程, 每个线程都会调用==method1==方法, 然后都会再从新创建一个新的==arrayList==对象, 这个新对象再传递给method2,method3方法.

- list 是局部变量，每个线程调用时会创建其不同实例，没有共享

  

```java
class UnsafeTest {
    public void method1() {
        ArrayList<String> arrayList = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            method2(arrayList);
            method3(arrayList);
        }
    }

    private void method2(List<String> arrayList) {
        arrayList.add("1");
    }

    private void method3(List<String> arrayList) {
        arrayList.remove(0);
    }
}
```

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210624010343947.png" alt="image-20210624010343947" style="zoom:50%;" />	

### 5、==private== 或 ==final==的重要性 (==重要==)

> 提高线程的安全性

- 方法访问修饰符带来的思考: 如果把method2和method3 的方法修改为==public== 会不会导致线程安全问题; 分情况:

- **情况1：有其它线程调用 method2 和 method3**
  - 只修改为==public==修饰,此时==不会出现线程安全==的问题, **即使线程2调用method2/3方法, 给2/3方法传过来的==list对象==也是线程2调用method1方法时,传递给method2/3的list对象, 不可能是线程1调用method1方法传的对象。** 

- **情况2：在情况1 的基础上，为ThreadSafe 类添加子类，子类覆盖==method2 或 method3==方法**，即如下所示： 从这个例子可以看出 ==private== 或 ==final== 提供【安全】的意义所在，请体会==开闭原则中的【闭】==

> - **如果改为public, 此时子类可以重写父类的方法, 在子类中==开线程==来操作==list对象==, 此时就会出现==线程安全问题: 子类和父类共享了list对象==**
> - **如果改为private, 子类就不能重写父类的私有方法, 也就不会出现线程安全问题; 所以所==private修饰符==是可以避免线程安全问题.**
> - **所以如果不想子类, 重写父类的方法的时候, 我们可以将父类中的方法设置为==private, final==修饰的方法, 此时子类就无法影响父类中的方法了!**

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    public void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}
```

### 6、常见线程安全类

- String
- Integer
- StringBuffer
- Random
- Vector
- Hashtable
- java.util.concurrent 包下的类 JUC

**==重点:==**

- 这里==说它们是线程安全==的是指，**==多个线程调用它们同一个实例的某个方法时，是线程安全的==** , 也可以理解为 **==它们的每个方法是原子的==**
- 它们的每个方法是原子的==（方法都被加上了synchronized）==
- 但注意它们==多个方法的组合不是原子的==，所以可能**会出现线程安全问题**

```java
//这里虽然多个线程调用put方法，他依然是线程安全的
Hashtable table = new Hashtable();

new Thread(()->{
	// put方法增加了synchronized
 	table.put("key", "value1");
}).start();

new Thread(()->{
 	table.put("key", "value2");
}).start();
```

**线程安全类方法的组合**

- 但注意==它们多个方法的组合不是原子的==，见下面分析
  - 这里只能是get方法内部是线程安全的, put方法内部是线程安全的. 组合起来使用还是会受到==上下文切换==的影响

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
 table.put("key", value);
}
```

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210624104447678.png" alt="image-20210624104447678" style="zoom:50%;" />

**不可变类的线程安全**

- ==String==和==Integer==类都是==不可变的类==，因为其类内部==状态是不可改变==的，因此**它们的方法都是线程安全的**, 都被==final==修饰, 不能被继承.
- 肯定有些人他们知道==String== 有 ==replace==，==substring== 等方法【==可以】改变值啊==，**其实调用这些方法返回的已经是一个新创建的对象了！** ==(在字符串常量池中当修改了String的值,它不会再原有的基础上修改, 而是会重新开辟一个空间来存储)==

***示例分析-是否线程安全***

**示例一**

- ==Servlet运行在Tomcat环境下并只有一个实例==，因此会被Tomcat的多个线程共享使用，因此存在成员变量的共享问题。

  ==hashmap==线程不安全举例

```java
public class MyServlet extends HttpServlet {
	 // 是否安全？  否：HashMap不是线程安全的，HashTable是
	 Map<String,Object> map = new HashMap<>();
	 // 是否安全？  是:String 为不可变类，线程安全
	 String S1 = "...";
	 // 是否安全？ 是
	 final String S2 = "...";
	 // 是否安全？ 否：不是常见的线程安全类
	 Date D1 = new Date();
	 // 是否安全？  否：引用值D2不可变，但是日期里面的其它属性比如年月日可变。与字符串的最大区别是Date里面的属性可变。
	 final Date D2 = new Date();
 
	 public void doGet(HttpServletRequest request,HttpServletResponse response) {
	  // 使用上述变量
	 }
}
```

**示例二**

- **分析线程是否安全**，先==对类的成员变量，类变量，局部变量==进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题了，如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A是线程安全的的。下面对实例一进行分析：此类不是线程安全的。**==MyAspect==切面类只有一个实例，成员变量==start== 会被多个线程同时进行读写操作**

- **Spring中的Bean都是==单例==的, 除非使用==@Scope==修改为多例。**

```java
@Aspect
@Component 
public class MyAspect {
        // 是否安全？不安全, 因为MyAspect是单例的
        private long start = 0L;

        @Before("execution(* *(..))")
        public void before() {
            start = System.nanoTime();
        }

        @After("execution(* *(..))")
        public void after() {
            long end = System.nanoTime();
            System.out.println("cost time:" + (end-start));
        }
    }
```



# 六、Monitor

## 1、 Java 对象头 ==(重点)==

**对象头包含两部分：==运行时元数据（Mark Word）==和==类型指针 (Klass Word)==**

1.**==运行时元数据==**

- ==哈希值（HashCode）==，可以看作是**堆中对象的地址**
- ==GC分代年龄（年龄计数器）== (用于新生代from/to区晋升老年代的标准, 阈值为15)
- **锁状态标志** (用于JDK1.6对synchronized的优化 -> 轻量级锁)
- **线程持有的锁**
- **偏向线程ID** (用于JDK1.6对synchronized的优化 -> 偏向锁)
- 偏向时间戳

2.**==类型指针==**

- 指向==类元数据InstanceKlass，确定该对象所属的类型==。指向的其实是**方法区中存放的类元信息**

> 说明：**如果对象是数组，还需要记录数组的长度**



以 32 位虚拟机为例,普通对象的对象头结构如下，其中的==Klass Word==为==类型指针==，指向==方法区==对应的==Class对象==；

**普通对象**

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210625113114420.png" alt="image-20210625113114420" style="zoom:50%;" />	

**数组对象**

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210625113209020.png" alt="image-20210625113209020" style="zoom:50%;" />	

**==其中 Mark Word 结构为:== ==无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)==**

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210625113255206.png" alt="image-20210625113255206" style="zoom:50%;" />	

*64 位虚拟机 Mark Word*

<img src="/Users/qianwei/Library/Application Support/typora-user-images/image-20210625113516841.png" alt="image-20210625113516841" style="zoom:50%;" />	

**所以一个对象的结构如下：**

<img src="https://img-blog.csdnimg.cn/img_convert/1844b5e3159baa3c8fb78478daa1580b.png" alt="1583678624634"  />	

## 2、 Monitor 原理 (Synchronized底层实现-重量级锁)

**多线程同时访问临界区: 使用重量级锁**

- JDK6对Synchronized的优先状态：==偏向锁–>轻量级锁–>重量级锁==

  

==Monitor==被翻译为==监视器==或者==管程==

==每个Java对象==**都可以**==关联一个(操作系统的)Monitor==**，如果使用**==synchronized==**给**==对象上锁（重量级）==**，**该**==对象头的MarkWord==**中就被设置为**==指向Monitor对象==**的==指针==

> 下图原理解释:
>
> 当==Thread2==访问到==synchronized(obj)==中的==共享资源==的时候
>
> - 首先会将synchronized中的==锁对象==中==对象头==的==MarkWord==去尝试指向==操作系统==的==Monitor==对象. 让锁对象中的MarkWord和Monitor对象相关联. 如果关联成功, 将obj对象头中的==MarkWord==的==对象状态==从01改为10。
>
> - 因为Monitor没有和其他的obj的MarkWord相关联, 所以==Thread2==就成为了该==Monitor==的Owner(所有者)。
>
> - 又来了个==Thread1==执行synchronized(obj)代码, 它首先会看看能不能执行该==临界区==的代码; 它会检查obj是否关联了Montior, 此时已经有关联了, 它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2);==Thread1==也会和该Monitor关联, 该线程就会进入到它的==EntryList(阻塞队列)==;
>
> - 当==Thread2==执行完==临界区==代码后, Monitor的==Owner(所有者)==就空出来了. 此时就会==通知==Monitor中的EntryList阻塞队列中的线程, 这些线程通过==竞争==, 成为新的==所有者==
>
>   <img src="https://img-blog.csdnimg.cn/20201219192811839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />
>
>   ​	

<img src="https://img-blog.csdnimg.cn/img_convert/98c3189e41fd654fe34ead273ec76eba.png" alt="1583652360228" style="zoom: 67%;" />	

- 刚开始时==Monitor==中的==Owner为null==
- **当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner**
- 当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入==EntryList==中变成==BLOCKED状态==
- **Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，==竞争时是非公平的 (仍然是抢占式)==**
- ==图中 WaitSet 中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析==

> **注意：**
>
> - synchronized 必须是进入同一个锁对象的monitor 才有上述的效果; —> 也就要使用同一把锁
>
> - 不加 synchronized的锁对象不会关联监视器，不遵从以上规则
>
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219200615817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

> 它加锁就是依赖底层操作系统的 ==mutex==相关指令实现, 所以会造成==用户态和内核态之间的切换==, ==非常耗性能== !
>
> - 在JDK6的时候, 对synchronized进行了优化, 引入了==轻量级锁, 偏向锁==, 它们是在==JVM==的层面上进行加锁逻辑, 就没有了切换的消耗

## 3、synchronized原理

```JAVA
static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
    synchronized (lock) {
        counter++;
    }
}
```

以上代码反编译后的部分字节码**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219201521709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

> ==注意==：方法级别的 synchronized 不会在字节码指令中有所体现

## 4、synchronized 原理进阶

### **小故事**

故事角色

- 老王 - JVM

- 小南 - 线程

- 小女 - 线程

- 房间 - 对象

- 房间门上 - 防盗锁 - Monitor

- 房间门上 - 小南书包 - 轻量级锁

- 房间门上 - 刻上小南大名 - 偏向锁

- 批量重刻名 - 一个类的偏向锁撤销到达 20 阈值

- 不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向

  小南要使用房间保证计算不被其它人**干扰(原子性)**，最初，他用的是**防盗锁**，当上下文切换时，锁住门。这样，

即使他离开了，别人也进不了门，他的工作就是安全的。

​		但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女

晚上用。每次上锁太麻烦了，有没有更简单的办法呢?

​		小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因

此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是

自己的，那么就在门外等，并通知对方下次用锁门的方式。	**==（轻量级锁）==**

​		后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍

然觉得麻烦。

​		于是，小南干脆在门上刻上了自己的名字:【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那

么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦

掉，升级为挂书包的方式。

​		同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老 家了，这时小女回来了(她也要用这些房间)，结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老 王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字

​		后来，刻名的现象越来越频繁，老王受不了了:算了，这些房间都不能刻名了，只能挂书包	

> 而JDK1.6以后引入偏向锁和轻量级锁在JVM层面实现加锁的逻辑，不依赖底层操作系统，就没有切换的消耗所以。
>
> Mark Word对锁的状态记录一共有4种:==无锁、偏向锁、轻量级锁和重量级锁==。

## 5、轻量级锁 (用于优化Monitor这类的重量级锁）

> 通过==锁记录==的方式, 场景 : **多个线程交替进入临界区**

- **==轻量级锁的使用场景==: 如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用==轻量级锁来进行优化==。**
- 轻量级锁对使用者是透明的，即语法仍然是==synchronized== (jdk6对synchronized的优化)，假设有两个方法同步块，利用同一个对象加锁
- **==eg:==** 线程A来操作临界区的资源, ==给资源加锁,到执行完临界区代码,释放锁==的过程, 没有线程来竞争, 此时就可以使用==轻量级锁==; **如果==这期间==有线程来竞争的话, 就会==升级为重量级锁(synchronized)==**

```java
static final Object obj = new Object();
public static void method1() {
     synchronized( obj ) {
         // 同步块 A
         method2();
     }
}
public static void method2() {
     synchronized( obj ) {
         // 同步块 B
     }
}
```

- 每次指向到==synchronized代码块==时，都会在==栈帧中==创建==锁记录（Lock Record）对象==，**==每个线程都会包括一个锁记录的结构==**，锁记录内部可以储存==对象的MarkWord==和==锁对象引用reference==

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219205033458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 在轻量级锁状态下，当前线程会在栈帧 下创建Lock Record, LockRecord会把Mark Word的信息拷贝进去，且有个Ow
  ner指针指向加锁的对象

- 线程执行到同步代码时，则用CAS试图将Mark Word的指向到线程栈帧的Lock Record,假设CAS修改成功，则获取得
  到轻量级锁

  <img src="https://img-blog.csdnimg.cn/img_convert/4d42844c6ddc19a6f94d954ae5a0cc79.png" alt="1583755737580" style="zoom:67%;" />	

- 让==锁记录==中的==Object reference指向锁对象地址==，并且尝试用==CAS(compare and sweep)==将==栈帧中的锁记录的(lock record 地址 00)==替换==Object对象的Mark Word==，将**Mark Word 的值(01)存入锁记录(lock record地址)中** ------==相互替换==

  - 01 表示 ==无锁== ==(看Mark Word结构, 数字的含义)==

  - 00表示 ==轻量级锁==

    <img src="https://img-blog.csdnimg.cn/img_convert/87f63c5373eed35d0bf65e0b510a7660.png" alt="1583755888236" style="zoom:67%;" />	

**==重点:==**

- 如果==cas替换成功==, 获得了轻量级锁，那么==对象==的==对象头储存的就是锁记录的地址和状态00==，如下所示

  - **线程中锁记录, 记录了锁对象的锁状态标志; 锁对象的对象头中存储了锁记录的地址和状态, 标志哪个线程获得了锁**

  - 此时==栈帧==中存储了==对象的对象头==中的==锁状态标志==,年龄计数器,哈希值等; ==对象的对象头中==就存储了==栈帧中锁记录的地址和状态00==, 这样的话==对象==就知道了是==哪个线程锁住自己==

    <img src="https://img-blog.csdnimg.cn/img_convert/68c40cfc17498b1514fe31af8a896eaf.png" alt="1583755964276" style="zoom:67%;" />	

- 如果==cas替换失败，有两种情况== : **① 锁膨胀 ② 重入锁失败**

  - 1、如果是==其它线程==已经持有了==该Object的轻量级锁==，那么表示**有竞争**，将进入 **==锁膨胀阶段==**

    - 此时==对象Object==对象头中已经存储了别的线程的==锁记录地址 00==,指向了其他线程;

  - 2、如果是==自己的线程已经执行了synchronized进行加锁==，那么==再添加一条 Lock Record 作为重入锁的计数== – 线程多次加锁, 锁重入

    - 在上面代码中,==临界区中==又调用了==method2==, method2中又进行了一次==synchronized加锁操作==, 此时就会在==虚拟机栈==中再开辟一个method2方法对应的栈帧(栈顶), 该栈帧中又会存在一个==独立==的==Lock Record==, 此时它发现==对象的对象头中指向的就是自己线程中栈帧的锁记录==; 加锁也就失败了. 这种现象就叫做==锁重入==; 线程中有多少个锁记录, 就能表明该线程对这个对象加了几次锁 (锁重入计数)

      <img src="https://img-blog.csdnimg.cn/img_convert/9e36f456637862001c9c58ded2651a3b.png" alt="1583756190177" style="zoom:67%;" />	

**==轻量级锁解锁流程 :==**

- 当线程退出synchronized代码块的时候，如果获取的是取值为 **null** 的锁记录 ，表示有锁重入，这时重置锁记录，表示重入计数减一



<img src="https://img-blog.csdnimg.cn/img_convert/6e5c1ae4a693ec26d8c629fda57737c3.png" alt="1583756357835" style="zoom:67%;" />	

- 当线程退出synchronized代码块的时候，如果==获取的锁记录取值不为 null==，那么使用cas将Mark Word的值恢复给对象, 将直接替换的内容还原。
  - 成功则解锁成功 (轻量级锁解锁成功)
  - 失败，表示有竞争, 则==说明轻量级锁进行了锁膨胀==或==已经升级为重量级锁==，**进入重量级锁解锁流程 (Monitor流程)**



## 6、锁膨胀(?)

- 如果在尝试==加轻量级锁==的过程中，==cas替换操作无法成功==，这是**有一种情况就是其它线程已经为这个对象加上了轻量级锁**，这是就要进行==锁膨胀(有竞争)==，**==将轻量级锁变成重量级锁。==**
- 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁, 此时发生==锁膨胀==

![1583757433691](https://img-blog.csdnimg.cn/img_convert/c3e0a92d418c70280fd2a0bb730eea82.png)

- 这时Thread-1加轻量级锁失败，**进入锁膨胀流程**
  - **因为==Thread-1==线程加轻量级锁失败, 轻量级锁没有阻塞队列的概念**, 所以此时就要==为对象申请Monitor锁(重量级锁)==，让==Object指向重量级锁地址 10==，然后==自己进入Monitor 的EntryList 变成BLOCKED状态==

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219214748700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

当==Thread-0 线程==执行完==synchronized同步块==时，**使用cas将Mark Word的值恢复给对象头**, 肯定恢复失败,因为对象的对象头中存储的是==重量级锁的地址,状态变为10了==之前的是00, 肯定恢复失败。那么会==进入重量级锁的解锁过程==，即按照==Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的Thread-1线程==

## 7、自旋锁优化 (优化重量级锁竞争)

 当发生==重量级锁竞争的时候==，还可以使用==自旋来进行优化 (不加入Monitor的阻塞队列EntryList中)==，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），**那么当前线程就可以不用进行上下文切换**(==持锁线程执行完synchronized同步块后,释放锁,Owner为空,唤醒阻塞队列来竞争,胜出的线程得到cpu执行权的过程==) 就获得了锁

> 优化的点: 不用将==线程==加入到阻塞队列, 减少cpu切换.

1、自旋重试成功的情况

<img src="https://img-blog.csdnimg.cn/img_convert/39ed180b2ab7eae1bc37ebba0a819c4c.png" alt="1583758113724" style="zoom:67%;" />	

2、自旋重试失败的情况==，**自旋了一定次数还是没有等到持锁的线程释放锁**, 线程2就会加入Monitor的阻塞队列(EntryList)

<img src="https://img-blog.csdnimg.cn/img_convert/36162c78749df99fcd83560e3896aef0.png" alt="1583758136650" style="zoom:67%;" />	

- **自旋会==占用 CPU 时间==，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势**。
- 在 ==Java 6 之后自旋锁是自适应==的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能

## 8、偏向锁 (biased lock) (用于优化轻量级锁重入)

> 场景: 没有竞争的时候, 一个线程中多次使用==synchronized==需要重入加锁的情况; **(只有一个线程进入临界区)**
>
> - 在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭
>
> - **将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了**

- 在==轻量级的锁==中，我们可以发现，如果同一个线程对同一个对象进行==重入锁==时，**也需要执行CAS替换操作，这是有点耗时。**
- 那么java6开始引入了==偏向锁==，**将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了**
  - **升级为轻量级锁的情况 (会进行偏向锁撤销)** : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作成功了, 此时该线程就获得了锁对象。( ==此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁==)
  - **升级为重量级锁的情况 (会进行偏向锁撤销)** : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作失败了, 此时说明发生了锁竞争。( ==此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁==)

例如：

```java
public class Test {
    static final Object obj = new Object();

    public static void m1() {
        synchronized (obj) {
            // 同步块A
            m2();
        }
    }

    public static void m2() {
        synchronized (obj) {
            // 同步块B
            m3();
        }
    }

    public static void m3() {
        synchronized (obj) {
            // 同步块C
        }
    }
}
```

<img src="https://img-blog.csdnimg.cn/20201219223917148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" />	

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219223934280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)	

<img src="https://img-blog.csdnimg.cn/20210202174407252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" />	

<img src="https://img-blog.csdnimg.cn/20210202174448323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" />	

### 8.1、偏向锁状态 (了解)

- ==运行时元数据（Mark Word）==的结构如下:

  <img src="https://img-blog.csdnimg.cn/img_convert/4b3e8d91dabdf79eb0ab250835c6bbc0.png" alt="1583762169169" style="zoom:80%;" />	

- ==Normal：一般状态，没有加任何锁==**，前面62位保存的是对象的信息，最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）**

- ==Biased：偏向状态，使用偏向锁==**，前面54位保存的当前线程的ID，最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）**

- ==Lightweight：使用轻量级锁==**，前62位保存的是锁记录的指针，最后2位为状态（00）**

- ==Heavyweight：使用重量级锁==**，前62位保存的是Monitor的地址指针，最后2位为状态(10)**

<img src="https://img-blog.csdnimg.cn/img_convert/461b804dda9e6ee0737faf0519ca295c.png" alt="img" style="zoom:75%;" />

- 如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101
- 但是偏向锁默认是**有延迟**的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态
- 如果没有开启偏向锁，对象的Mark Word后三位应该是001

#### **一个对象的创建过程**

- **如果开启了**==偏向锁（默认是开启的）==**，那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的**==ThreadId==**，**==epoch==**，**==age(年龄计数器)==**都是**==0==**，在加锁的时候进行设置这些的值.**

- ****==偏向锁默认是延迟==**的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：==-XX:BiasedLockingStartupDelay=0==来禁用延迟**

- ###### **注意** : ==处于偏向锁的对象解锁后，线程id仍存储于对象头中==

  <img src="https://img-blog.csdnimg.cn/20201219230315160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" />	

  输出结果:

  <img src="https://img-blog.csdnimg.cn/20201219230503664.png" alt="在这里插入图片描述" style="zoom:80%;" />	

  测试==禁用偏向锁==：如果==没有开启偏向锁==，那么对象创建后最后三位的值为==001==，这时候它的hashcode，age都为0，hashcode是第一次用到==hashcode==时才赋值的。在上面测试代码运行时在添加 VM 参数==-XX:-UseBiasedLocking==禁用偏向锁==（禁用偏向锁则优先使用轻量级锁）==，退出==synchronized==状态变回 **001**

  - 禁止偏向锁, 虚拟机参数==-XX:-UseBiasedLocking==; 优先使用==轻量级锁==
  - 输出结果: 最开始状态为001，然后加轻量级锁变成00，最后恢复成001

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219231656738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

### 8.2、撤销偏向锁-hashcode方法 (了解)

<img src="https://img-blog.csdnimg.cn/202012192322377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"  />

- 测试 ==hashCode==：当==调用对象的hashcode方法==的时候就会==撤销这个对象的偏向锁==，**因为使用偏向锁时没有位置存==hashcode==的值了**

### 8.3、撤销偏向锁-发生锁竞争 (升级为重量级锁)

> 小故事: 线程A门上刻了名字, 但此时线程B也要来使用房间了, 所以要将偏向锁升级为轻量级锁. (线程B要在线程A使用完房间之后==(执行完synchronized代码块)==,再来使用; 否则就成了竞争获取锁对象, 此时就要升级为==重量级锁==了)

> **偏向锁、轻量级锁的使用条件, 都是在于多个线程没有对同一个对象进行==锁竞争==的前提下, 如果有==锁竞争==,此时就使用重量级锁。**

-  这里我们演示的是==偏向锁==撤销, 变成==轻量级锁==的过程，**那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行==锁竞争==**，我们使用==wait== 和 ==notify== 来辅助实现

-  虚拟机参数==-XX:BiasedLockingStartupDelay=0==确保我们的程序最开始使用了==偏向锁==

<img src="https://img-blog.csdnimg.cn/20201219234125463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"  />

- 输出结果，**最开始使用的是==偏向锁==**，**但是第二个线程尝试获取对象锁时(前提是: 线程一已经释放掉锁了,也就是执行完synchroized代码块)**，发现本来对象==偏向的是线程一==，那么偏向锁就会失效，加的就是==轻量级锁==


### 8.4、撤销偏向锁 - 调用 wait/notify (只有重量级锁才支持这两个方法)

**（调用wait方法会导致锁膨胀而使用重量级锁）**

- **会使对象锁变成重量级锁**，因为==wait/notify方法之后重量级锁才支持==

## 9、批量重偏向

- 如果==对象被多个线程访问，但是没有竞争 (上面撤销偏向锁就是这种情况: 一个线程执行完, 另一个线程再来执行, 没有竞争)==, 这时==偏向T1的对象仍有机会重新偏向T2==
  - 重偏向会重置Thread ID

- 当==撤销偏向锁101 升级为 轻量级锁00==超过==20次后（超过阈值）==，JVM会觉得是不是偏向错了，这时会在==给对象加锁时，重新偏向至加锁线程 (T2)。==

### 9.1、批量撤销偏向锁

- 当 撤销偏向锁的阈值超过40以后 ，就会将整个类的对象都改为**不可偏向**的

### 9.2、同步省略 (锁消除)

> **同步省略**

1.  线程同步的代价是相当高的，同步的后果是==降低并发性和性能==。
2.  在动态编译同步块的时候，==JIT编译器==可以==借助逃逸分析==来判断同步块所**使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。**
3.  如果没有，==那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。==这个**取消同步的过程就叫同步省略，也叫锁消除**。

例如下面的智障代码，==根本起不到锁的作用==

```java
public void f() {
    Object hellis = new Object();
    synchronized(hellis) {
        System.out.println(hellis);
    }
}
```

- 代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：

```java
public void f() {
    Object hellis = new Object();
	System.out.println(hellis);
}
```

**字节码分析**

- 代码

```java
public void f() {
    Object hellis = new Object();
    synchronized(hellis) {
        System.out.println(hellis);
    }
}
```

- 注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，**==同步省略操作是在解释运行时发生的==**

  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI5MTAzNjUwMzA5LnBuZw?x-oss-process=image/format,png" alt="image-20200729103650309" style="zoom:80%;" />	

一、[ wait和notify原理、同步模式之保护性暂停、异步模式之生产者/消费者、park和unpark原理、线程状态转换](https://blog.csdn.net/m0_37989980/article/details/111412907)

# 七、[ wait和notify原理、同步模式之保护性暂停、异步模式之生产者/消费者、park和unpark原理、线程状态转换](https://blog.csdn.net/m0_37989980/article/details/111412907)

## 一、wait和notify (==重点==)

### 1、小故事

<img src="https://img-blog.csdnimg.cn/20201220084049915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" />

<img src="https://img-blog.csdnimg.cn/20201220084213239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

### 2、wait、notify介绍 (必须要获取到锁对象, 才能调用这些方法)

<img src="https://img-blog.csdnimg.cn/20201220084652893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />

-  当**线程0**获得到了锁, 成为**Monitor**的**Owner**, 但是此时它发现自己想要执行synchroized代码块的条件不满足; 此时它就调用**obj.wait**方法, 进入到Monitor中的**WaitSet**集合, 此时线程0的状态就变为**WAITING**
-  处于**BLOCKED和WAITING**状态的线程都为阻塞状态，CPU都不会分给他们时间片。但是有所区别：
   -  **BLOCKED状态**的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于**BLOCKED状态**
   -  **WAITING状态**的线程是**获得了对象的锁**，但是自身的原因无法执行synchroized的临界区资源需要进入**阻塞状态**时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态
   -  处于**BLOCKED**状态的线程会在锁被释放的时候被唤醒
   -  处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。然后它会进入到EntryList, 重新竞争锁 (此时就将锁升级为**重量级锁**)

### 3、API介绍

下面的三个方法都是==Object==中的方法; 通过==锁对象==来调用

- **wait():** 让获得对象锁的线程到waitSet中一直等待
- **wait(long n) :** 当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒
- **notify():** 让获得对象锁的线程, 使用锁对象调用notify去waitSet的等待线程中挑一个唤醒
- **notifyAll() :** 让获得对象锁的线程, 使用锁对象调用notifyAll去唤醒waitSet中所有的等待线程

它们都是==线程之间进行协作的手段==, 都属于==Object对象的方法==, 必须获得此对象的锁, 才能调用这些方法

> **注：只有当对被锁以后(成为Owner)，才能调用wait和notify方法**

```java
public class Test1 {
	final static Object LOCK = new Object();
	public static void main(String[] args) throws InterruptedException {
        //只有在对象被锁住后才能调用wait方法
		synchronized (LOCK) {
			LOCK.wait();
		}
	}
}

```



- 演示==wait和notify==方法

```java
/**
 * Description:
 *
 * @author guizy
 * @date 2020/12/20 09:12
 */
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object obj = new Object();

    public static void main(String[] args) throws Exception {

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    // 只有获得锁对象之后, 才能调用wait/notify
                    obj.wait(); // 此时t1线程进入WaitSet等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...");
            }
        }, "t1").start();

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    obj.wait(); // 此时t2线程进入WaitSet等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...");
            }
        }, "t2").start();

        // 让主线程等两秒在执行,为了==唤醒==,不睡的话,那两个线程还没进入waitSet,主线程就开始唤醒了
        Thread.sleep(1000);
        log.debug("唤醒waitSet中的线程!");
        // 只有获得锁对象之后, 才能调用wait/notify
        synchronized (obj) {
            // obj.notify(); // 唤醒waitset中的一个线程
             obj.notifyAll(); // 唤醒waitset中的全部等待线程
        }
    }
}

13:01:36.176 guizy.WaitNotifyTest [t1] - 执行...
13:01:36.178 guizy.WaitNotifyTest [t2] - 执行...
13:01:37.175 guizy.WaitNotifyTest [main] - 唤醒waitSet中的线程!
13:01:37.175 guizy.WaitNotifyTest [t2] - 其它代码...
13:01:37.175 guizy.WaitNotifyTest [t1] - 其它代码...

```

### 4、Sleep(long n) 和 Wait(long n)的区别 ==(重点)==

**不同点**

- ==Sleep是Thread类的静态方法==，==Wait是Object的方法==，Object又是所有类的父类，所以所有类都有Wait方法。

- ==Sleep在阻塞的时候不会释放锁==，而==Wait在阻塞的时候会释放锁 (不释放锁的话, 其他线程就无法唤醒该线程了)==

- Sleep方法不需要与synchronized一起使用，**而Wait方法需要与synchronized一起使用（wait/notify等方法, 必须要使用对象锁来调用）**

**相同点**

- ==阻塞状态==都为==TIMED_WAITING (限时等待)==

**sleep方法 / wait方法 测试**

```java
/**
 * Description: 测试sleep不释放锁
 *
 * @author guizy
 * @date 2020/12/20 09:33
 */
@Slf4j(topic = "guizy.SleepTest")
public class SleepTest {

    public static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (lock) {
                log.debug("获得锁了");
                try {
                    // Thread.sleep(5000); // 主线程需要等5s才能获得到锁.所以所在sleep期间, 是不会释放锁的
                    lock.wait(5000); // 调用wait方法会立刻释放锁, 不然主线程就拿不到lock锁了, 当等待5s后程序才结束
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t1").start();

        // 主线程睡一秒
        Sleeper.sleep(1);
        synchronized (lock) {
            log.debug("获得锁了");
        }
}

```

sleep打印结果 : 表明在sleep期间, 锁是不会被释放的

![在这里插入图片描述](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/20201220094013513.png)

wait打印结果 : 当调用wait方法后, 锁就会被立刻释放

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220094129242.png)

### 5、wait/notify的正确使用

**Step 1 : 逐渐向下优化**

```java
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        //思考下面的解决方案好不好，为什么？
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    Sleeper.sleep(2);   // 会阻塞2s, 不会释放锁
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                synchronized (room) {
                    log.debug("可以开始干活了");
                }
            }, "其它人").start();
        }

        Sleeper.sleep(1);
        new Thread(() -> {
            // 此时没有加锁, 所以会优先于其他人先执行
            // 这里能不能加 synchronized (room)？
            //synchronized (room) { // 如果加锁的话, 送烟人也需要等待小南睡2s的时间,此时即使送到了,小南线程也将锁释放了..
                hasCigarette = true;
                log.debug("烟到了噢！");
            //}
        }, "送烟的").start();
    }
}

```

- 不给==送烟线程加synchronized==输出情况

  ```java
  10:16:32.311 guizy.WaitNotifyTest [小南] - 有烟没？[false]
  10:16:32.318 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
  10:16:33.318 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
  10:16:34.320 guizy.WaitNotifyTest [小南] - 有烟没？[true]
  10:16:34.320 guizy.WaitNotifyTest [小南] - 可以开始干活了
  10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  10:16:34.321 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  10:16:34.321 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  ```

- 给==送烟线程加synchronized==输出情况

  ```java
  10:16:57.565 guizy.WaitNotifyTest [小南] - 有烟没？[false]
  10:16:57.570 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
  10:16:59.574 guizy.WaitNotifyTest [小南] - 有烟没？[false]
  10:16:59.574 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
  10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  10:16:59.576 guizy.WaitNotifyTest [其它人] - 可以开始干活了
  ```

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220101906421.png)

**Step2:**

```java
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait(); // 此时进入到waitset等待集合, 同时会释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                // 小南进入等待状态了, 其他线程就可以获得锁了
                synchronized (room) {
                    log.debug("可以开始干活了");
                }
            }, "其它人").start();
        }

        Sleeper.sleep(1);
        new Thread(() -> {
            synchronized (room) {
                hasCigarette = true;
                log.debug("烟到了噢！");
                room.notify();
            }
        }, "送烟的").start();
    }
}

```

```java
11:00:51.840 guizy.WaitNotifyTest [小南] - 有烟没？[false]
11:00:51.847 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:51.847 guizy.WaitNotifyTest [其它人] - 可以开始干活了
11:00:52.847 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
11:00:52.847 guizy.WaitNotifyTest [小南] - 有烟没？[true]
11:00:52.848 guizy.WaitNotifyTest [小南] - 可以开始干活了
```

如果此时除了小南在等待唤醒, 还有一个线程也在等待唤醒呢? 此时的==notify==方法会唤醒谁呢?

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220110553609.png)

**Step3:**

```java
@Slf4j(topic = "guizy.WaitNotifyTest")public class WaitNotifyTest {    static final Object room = new Object();    static boolean hasCigarette = false;    static boolean hasTakeout = false;    public static void main(String[] args) {        new Thread(() -> {            synchronized (room) {                log.debug("有烟没？[{}]", hasCigarette);                if (!hasCigarette) {                    log.debug("没烟，先歇会！");                    try {                        room.wait(); // 此时进入到waitset等待集合, 同时会释放锁                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                log.debug("有烟没？[{}]", hasCigarette);                if (hasCigarette) {                    log.debug("可以开始干活了");                }            }        }, "小南").start();        new Thread(() -> {            synchronized (room) {                log.debug("外卖送到没？[{}]", hasTakeout);                if (!hasTakeout) {                    log.debug("没外卖，先歇会！");                    try {                        room.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                log.debug("外卖送到没？[{}]", hasTakeout);                if (hasTakeout) {                    log.debug("可以开始干活了");                } else {                    log.debug("没干成活...");                }            }        }, "小女").start();        Sleeper.sleep(1);        new Thread(() -> {            synchronized (room) {                hasTakeout = true;                log.debug("外卖到了噢！");                room.notify();            }        }, "送外卖的").start();    }}
```

```java
11:10:39.516 guizy.WaitNotifyTest [小南] - 有烟没？[false]11:10:39.521 guizy.WaitNotifyTest [小南] - 没烟，先歇会！11:10:39.521 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]11:10:39.521 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！11:10:40.521 guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！11:10:40.521 guizy.WaitNotifyTest [小南] - 有烟没？[false]
```

问题: 当外卖送到了, 却唤醒了==小南==, 此时就出现了问题

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220111243224.png)

**Step4:**

```java
new Thread(() -> { synchronized (room) {	 hasTakeout = true;	 log.debug("外卖到了噢！");	 room.notifyAll(); }}, "送外卖的").start();
```

```java
11:14:53.670 guizy.WaitNotifyTest [小南] - 有烟没？[false]11:14:53.676 guizy.WaitNotifyTest [小南] - 没烟，先歇会！11:14:53.676 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]11:14:53.676 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！11:14:54.674 guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！11:14:54.674 guizy.WaitNotifyTest [小女] - 外卖送到没？[true]11:14:54.674 guizy.WaitNotifyTest [小女] - 可以开始干活了11:14:54.675 guizy.WaitNotifyTest [小南] - 有烟没？[false]
```

还是唤醒了小南, 小南还是回去看看送来的是外卖还是烟. 很麻烦, 怎么解决?

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220111655619.png)

**Step5:**

- 使用==while循环==来解决==虚假唤醒==

```java
@Slf4j(topic = "guizy.WaitNotifyTest")public class Main {    static final Object room = new Object();    static boolean hasCigarette = false;    static boolean hasTakeout = false;    public static void main(String[] args) {        new Thread(() -> {            synchronized (room) {                log.debug("有烟没？[{}]", hasCigarette);                while (!hasCigarette) {                    log.debug("没烟，先歇会！");                    try {                        room.wait(); // 此时进入到waitset等待集合, 同时会释放锁                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                log.debug("有烟没？[{}]", hasCigarette);                if (hasCigarette) {                    log.debug("可以开始干活了");                }            }        }, "小南").start();        new Thread(() -> {            synchronized (room) {                log.debug("外卖送到没？[{}]", hasTakeout);                while (!hasTakeout) {                    log.debug("没外卖，先歇会！");                    try {                        room.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                log.debug("外卖送到没？[{}]", hasTakeout);                if (hasTakeout) {                    log.debug("可以开始干活了");                } else {                    log.debug("没干成活...");                }            }        }, "小女").start();        Sleeper.sleep(1);        new Thread(() -> {            synchronized (room) {                hasTakeout = true;                log.debug("外卖到了噢！");                room.notifyAll();            }        }, "送外卖的").start();    }}
```

```java
11:19:25.275 guizy.WaitNotifyTest [小南] - 有烟没？[false]11:19:25.282 guizy.WaitNotifyTest [小南] - 没烟，先歇会！11:19:25.282 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]11:19:25.283 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！11:19:26.287 guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！11:19:26.287 guizy.WaitNotifyTest [小女] - 外卖送到没？[true]11:19:26.287 guizy.WaitNotifyTest [小女] - 可以开始干活了11:19:26.288 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
```

因为改为==while==如果唤醒之后, 就在while循环中执行了, 不会跑到while外面去执行"有烟没…", 此时小南就不需要每次notify, 就去看是不是送来的烟, 如果是烟, while就为false了.

## 二、同步模式之保护性暂停 (==join、Future的实现==)

- 即==Guarded Suspension==，**==用在一个线程等待另一个线程的执行结果==**
  - 有==一个结果==需要从==一个线程传递到另一个线程==，让他们关联同一个 **GuardedObject**
  - 如果**有结果不断从一个线程到另一个线程** 那么可以使用==消息队列==（见生产者/消费者）
  - JDK 中，==join 的实现、Future 的实现==，采用的就是此模式
  - 因为要等待另一方的结果，因此归类到==同步模式==

![1594473284105](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/e73412e2618ca103105cce41f4b228c9.png)

- ==一方等待另一方的执行结果==举例 :
- 举例, 线程1等待线程2下载的结果,并获取该结果

```java
/** * Description: 多线程同步模式 - 一个线程需要等待另一个线程的执行结果 * * @author guizy1 * @date 2020/12/21 14:51 */@Slf4j(topic = "guizy.GuardeObjectTest")public class GuardeObjectTest {    public static void main(String[] args) {        // 线程1等待线程2的下载结果        GuardeObject guardeObject = new GuardeObject();        new Thread(() -> {            log.debug("等待结果");            List<String> list = (List<String>) guardeObject.get();            log.debug("结果大小:{}", list.size());        }, "t1").start();        new Thread(() -> {            log.debug("执行下载");            try {                List<String> list = Downloader.download();                guardeObject.complete(list);            } catch (IOException e) {                e.printStackTrace();            }        }, "t2").start();    }}class GuardeObject {    // 结果    private Object response;    // 获取结果    public Object get() {        synchronized (this) {            // 防止虚假唤醒            // 没有结果            while (response == null) {                try {                    this.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            return response;        }    }    // 产生结果    public void complete(Object response) {        synchronized (this) {            // 给结果变量赋值            this.response = response;            this.notifyAll();        }    }}
```

- ==线程t1== 等待 ==线程t2==的结果, 可以==设置超时时间==, 如果超过时间还没返回结果,此时就不等了.退出while循环

```java
@Slf4j(topic = "guizy.GuardeObjectTest")public class GuardeObjectTest {    public static void main(String[] args) {        // 线程1等待线程2的下载结果        GuardeObject guardeObject = new GuardeObject();        new Thread(() -> {            log.debug("begin");            Object obj = guardeObject.get(2000);            log.debug("结果是:{}", obj);        }, "t1").start();        new Thread(() -> {            log.debug("begin");            // Sleeper.sleep(1); // 在等待时间内            Sleeper.sleep(3);            guardeObject.complete(new Object());        }, "t2").start();    }}class GuardeObject {    // 结果    private Object response;    // 获取结果    // timeout表示等待多久. 这里假如是2s    public Object get(long timeout) {        synchronized (this) {            // 假如开始时间为 15:00:00            long begin = System.currentTimeMillis();            // 经历的时间            long passedTime = 0;            while (response == null) {                // 这一轮循环应该等待的时间                long waitTime = timeout - passedTime;                // 经历的时间超过了最大等待时间, 退出循环                if (waitTime <= 0) {                    break;                }                try {                    // this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,                    // 进入while循环的时候response还是空,此时判断1s<=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了                    // 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)                    this.wait(waitTime);                } catch (InterruptedException e) {                    e.printStackTrace();                }                // 经历时间                passedTime = System.currentTimeMillis() - begin; // 15:00:02            }            return response;        }    }    // 产生结果    public void complete(Object response) {        synchronized (this) {            // 给结果变量赋值            this.response = response;            this.notifyAll();    }}
```

```java
// 在等待时间内的情况16:20:41.627 guizy.GuardeObjectTest [t1] - begin16:20:41.627 guizy.GuardeObjectTest [t2] - begin16:20:42.633 guizy.GuardeObjectTest [t1] - 结果是:java.lang.Object@1e1d0168// 超时的情况16:21:24.663 guizy.GuardeObjectTest [t2] - begin16:21:24.663 guizy.GuardeObjectTest [t1] - begin16:21:26.667 guizy.GuardeObjectTest [t1] - 结果是:null
```

- 关于超时的增强，在==join(long millis) 的源码==中得到了体现：

```java
public final synchronized void join(long millis)throws InterruptedException {    long base = System.currentTimeMillis();    long now = 0;    if (millis < 0) {        throw new IllegalArgumentException("timeout value is negative");    }    if (millis == 0) {        while (isAlive()) {            wait(0);        }    } else {    // join一个指定的时间        while (isAlive()) {            long delay = millis - now;            if (delay <= 0) {                break;            }            wait(delay);            now = System.currentTimeMillis() - base;        }    }}
```

- 多任务版==GuardedObject==图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类。

- 不仅能够==解耦==【结果等待者】和【结果生产者】，还能够同时支持==多个任务的管理==。和生产者消费者模式的区别就是：**这个==产生结果的线程==和==使用结果的线程==是==一一对应==的关系，但是生产者消费者模式并不是。**

- rpc框架的调用中就使用到了这种模式。

![1594518049426](https://img-blog.csdnimg.cn/img_convert/8af156fb943083720b551f6e52ddd03c.png)

```java
/** * Description: 同步模式保护性暂停模式 (多任务版) * * @author guizy1 * @date 2020/12/21 14:51 */@Slf4j(topic = "guizy.GuardedObjectTest")public class GuardedObjectTest {    public static void main(String[] args) {        for (int i = 0; i < 3; i++) {            new People().start();        }        Sleeper.sleep(1);        for (Integer id : Mailboxes.getIds()) {            new Postman(id, "内容" + id).start();        }    }}@Slf4j(topic = "guizy.People")class People extends Thread {    @Override    public void run() {        // 收信        GuardedObject guardedObject = Mailboxes.createGuardedObject();        log.debug("开始收信 id:{}", guardedObject.getId());        Object mail = guardedObject.get(5000);        log.debug("收到信 id:{}, 内容:{}", guardedObject.getId(), mail);    }}@Slf4j(topic = "guizy.Postman")// 邮寄员类class Postman extends Thread {    private int id;    private String mail;    public Postman(int id, String mail) {        this.id = id;        this.mail = mail;    }    @Override    public void run() {        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);        log.debug("送信 id:{}, 内容:{}", id, mail);        guardedObject.complete(mail);    }}// 信箱类class Mailboxes {    private static Map<Integer, GuardedObject> boxes = new Hashtable<>();    private static int id = 1;    // 产生唯一 id    private static synchronized int generateId() {        return id++;    }    public static GuardedObject getGuardedObject(int id) {        //根据id获取到box并删除对应的key和value,避免堆内存爆了        return boxes.remove(id);    }    public static GuardedObject createGuardedObject() {        GuardedObject go = new GuardedObject(generateId());        boxes.put(go.getId(), go);        return go;    }    public static Set<Integer> getIds() {        return boxes.keySet();    }}// 用来传递信息的作用, 当多个类使用GuardedObject,就很不方便,此时需要一个设计一个解耦的中间类class GuardedObject {    // 标记GuardedObject    private int id;    // 结果    private Object response;    public int getId() {        return id;    }    public GuardedObject(int id) {        this.id = id;    }    // 获取结果    // timeout表示等待多久. 这里假如是2s    public Object get(long timeout) {        synchronized (this) {            // 假如开始时间为 15:00:00            long begin = System.currentTimeMillis();            // 经历的时间            long passedTime = 0;            while (response == null) {                // 这一轮循环应该等待的时间                long waitTime = timeout - passedTime;                // 经历的时间超过了最大等待时间, 退出循环                if (waitTime <= 0) {                    break;                }                try {                    // this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,                    // 进入while循环的时候response还是空,此时判断1s<=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了                    // 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)                    this.wait(waitTime);                } catch (InterruptedException e) {                    e.printStackTrace();                }                // 经历时间                passedTime = System.currentTimeMillis() - begin; // 15:00:02            }            return response;        }    }    // 产生结果    public void complete(Object response) {        synchronized (this) {            // 给结果变量赋值            this.response = response;            this.notifyAll();        }    }}
```

## 三、异步模式之生产者/消费者 (==重点==)

- 与前面的==保护性暂停==中的 ==GuardedObject== 不同，**不需要**==产生结果==和==消费结果==的==线程一一对应 (一个生产一个消费)==
- **==消费队列==** 可以用来**平衡生产和消费的线程资源**
- **生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据**
- **消息队列是有==容量限制==的，满时不会再加入数据，空时不会再消耗数据**
- JDK 中各种 [阻塞队列](https://blog.csdn.net/yanpenglei/article/details/79556591)，采用的就是这种模式

异步模式中, 生产者产生消息之后消息没有被立刻消费
同步模式中, 消息在产生之后被立刻消费了。

![1594524622020](https://img-blog.csdnimg.cn/img_convert/82487e714da1c44453d46a61d6dcb27b.png)

- 我们下面写的小例子是==线程间通信==的==消息队列==，要注意区别,像==RabbitMQ==等消息框架是==进程间通信==的。

```java
package com.exampleone.demo.threadOne.bilibili;import lombok.extern.slf4j.Slf4j;import java.util.LinkedList;/** * Description: 异步模式之生产者/消费者 * @date 2020/12/21 18:23 */@Slf4j(topic = "ProductConsumerTest")public class ProductConsumerTest {    public static void main(String[] args) throws Exception{        MessageQueue queue = new MessageQueue(2);        for (int i = 0; i < 3; i++) {            int id = i;            new Thread(() -> {                queue.put(new Message(id, "值" + id));            }, "生产者" + i).start();        }        new Thread(() -> {            while (true) {                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                Message message = queue.take();            }        }, "消费者").start();    }}// 消息队列类,在线程之间通信@Slf4j(topic = "MessageQueue")class MessageQueue {    // 消息的队列集合    private LinkedList<Message> list = new LinkedList<>();    // 队列容量    private int capcity;    public MessageQueue(int capcity) {        this.capcity = capcity;    }    // 获取消息    public Message take() {        // 检查队列是否为空        synchronized (list) {            while (list.isEmpty()) {                try {                    log.debug("队列为空, 消费者线程等待");                    list.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            // 从队列头部获取消息并返回            Message message = list.removeFirst();            log.debug("已消费消息 {}", message);            list.notifyAll();            return message;        }    }    // 存入消息    public void put(Message message) {        synchronized (list) {            // 检查对象是否已满            while (list.size() == capcity) {                try {                    log.debug("队列已满, 生产者线程等待");                    list.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            // 将消息加入队列尾部            list.addLast(message);            log.debug("已生产消息 {}", message);            list.notifyAll();        }    }}final class Message {    private int id;    private Object value;    public Message(int id, Object value) {        this.id = id;        this.value = value;    }    public int getId() {        return id;    }    public Object getValue() {        return value;    }    @Override    public String toString() {        return "Message{" +                "id=" + id +                ", value=" + value +                '}';    }}
```

```java
00:10:41.997 [生产者1] DEBUG MessageQueue - 已生产消息 Message{id=1, value=值1}00:10:42.001 [生产者2] DEBUG MessageQueue - 已生产消息 Message{id=2, value=值2}00:10:42.001 [生产者0] DEBUG MessageQueue - 队列已满, 生产者线程等待00:10:42.998 [消费者] DEBUG MessageQueue - 已消费消息 Message{id=1, value=值1}00:10:42.999 [生产者0] DEBUG MessageQueue - 已生产消息 Message{id=0, value=值0}00:10:43.999 [消费者] DEBUG MessageQueue - 已消费消息 Message{id=2, value=值2}00:10:45.005 [消费者] DEBUG MessageQueue - 已消费消息 Message{id=0, value=值0}00:10:46.005 [消费者] DEBUG MessageQueue - 队列为空, 消费者线程等待
```

## 四、 park & unpack ==(重要)==

#### 1、基本使用

- ==park/unpark==都是==LockSupport==类中的的方法
- **先调用==unpark==后,再调用park, 此时==park==不会暂停线程**

```java
// 暂停当前线程LockSupport.park();// 恢复某个线程的运行LockSupport.unpark(thread);
```

#### 2、 park、 unpark 原理

==每个线程==都有自己的一个 ==Parker 对象==，由三部分组成 **==_counter==， ==_cond==和 ==_mutex==**

-  打个比喻线程就像一个旅人，Parker 就像他随身携带的背包，条件变量 _ cond就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足
-  **调用 park 就是要看需不需要停下来歇息**
   - 如果备用干粮耗尽，那么钻进帐篷歇息
   - 如果备用干粮充足，那么不需停留，继续前进
-  **调用 unpark，就好比令干粮充足**
   - 如果这时线程还在帐篷，就唤醒让他继续前进
   - 如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进
   - 因为背包空间有限，**==多次调用 unpark 仅会补充一份备用干粮==**

#### 先调用park再调用upark的过程

- **==先调用park的情况==**

  - 当前线程调用 **Unsafe.park()** 方法

  - **检查 _counter, 本情况为==0==,** 这时, 获得==_mutex 互斥锁==**(mutex对象有个等待队列 _cond)**

  - 线程进入 _cond 条件变量==阻塞==

  - 设置==_counter = 0== (没干粮了)

    ![1594531894163](https://img-blog.csdnimg.cn/img_convert/090e9cb2aed20d43c147ec0ea6470d5e.png)

- **==调用unpark==**

  - 调用==Unsafe.unpark(Thread_0)方法==，设置==_counter 为 1==
  - 唤醒 _cond 条件变量中的 Thread_0
  - Thread_0 ==恢复运行==
  - **设置 _counter 为 0**

![1594532057205](https://img-blog.csdnimg.cn/img_convert/ca03643f837f34098def91bfadc54bd6.png)

 **先调用upark再调用park的过程**

- 调用 ==Unsafe.unpark(Thread_0)==方法，设置 ==_counter 为 1==
- 当前==线程==调用 ==Unsafe.park()== 方法
- 检查 ==_counter==，本情况为 ==1==，这时线程 **==无需阻塞，继续运行==**
- 设置 _counter 为 0

![1594532135616](https://img-blog.csdnimg.cn/img_convert/d0d3270088a031c2066af2762e894413.png)



## 五、 线程状态转换 ==(重点)==

![img](https://img-blog.csdnimg.cn/img_convert/64146d2ab235481979b13ec4e9608fc5.png)



![img](https://img-blog.csdnimg.cn/20201221214359753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

**假设有线程 Thread t**

- 1、**NEW <–> RUNNABLE**
  - ==t.start()==方法时, ==NEW --> RUNNABLE==
- 2、**RUNNABLE <–> WAITING**
  - 线程用==synchronized(obj)==获取了==对象锁==后
    - 调用 **==obj.wait()==\**方法时，t 线程进入\**waitSet**中, 从==RUNNABLE --> WAITING==
    - 调用 **==obj.notify()==，==obj.notifyAll()==，==t.interrupt()==** 时, 唤醒的线程都到**entrySet**阻塞队列成为==BLOCKED==状态, 在阻塞队列,和其他线程再进行 **竞争锁**
      - **竞争锁成功**，t 线程从 ==WAITING --> RUNNABLE==
      - **竞争锁失败**，t 线程从 ==WAITING --> BLOCKED==
- 3、**RUNNABLE <–> WAITING**
  - **当前线程**调用 **==t.join()==** 方法时，**当前线程**从 ==RUNNABLE --> WAITING== ,注意是**当前线程**在t线程对象在**waitSet**上等待
  - **t 线程运行结束，或调用了当前线程的 interrupt() 时**，**当前线程**从 ==WAITING --> RUNNABLE==
- 4、**RUNNABLE <–> WAITING**
  - 当前线程调用 **==LockSupport.park()==** 方法会让**当前线程**从==RUNNABLE --> WAITING==
  - 调用 **==LockSupport.unpark(目标线程)==** 或调用了线程 的 **interrupt()** ，会让目标线程从 ==WAITING --> RUNNABLE==

**==Runnable 和 Timed-Waiting的相互转换==**

- 5、**RUNNABLE <–> TIMED_WAITING (带超时时间的wait)**
  - t 线程用==synchronized(obj)== 获取了==对象锁==后
    - 调用 **==obj.wait(long n)==** 方法时，t 线程从 ==RUNNABLE --> TIMED_WAITING==
    - t 线程等待时间超过了 n 毫秒，或调用 ==obj.notify() ， obj.notifyAll() ， t.interrupt()== 时; 唤醒的线程都到**entrySet**阻塞队列成为==BLOCKED==状态, 在阻塞队列,和其他线程再进行 **竞争锁**
      - 竞争锁成功，t 线程从 **TIMED_WAITING --> RUNNABLE**
      - 竞争锁失败，t 线程从 **TIMED_WAITING --> BLOCKED**
- 6、**RUNNABLE <–> TIMED_WAITING**
  - 当前线程调用 **==t.join(long n)==** 方法时，当前线程从 ==RUNNABLE --> TIMED_WAITING== 注意是当前线程在t 线程对象的**waitSet**等待
  - 当前线程调用 **==t.join(long n)==** 方法时，当前线程从 ==RUNNABLE --> TIMED_WAITING== 注意是当前线程在t 线程对象的**waitSet**等待
- 7、**RUNNABLE <–> TIMED_WAITING**
  - 当前线程调用 ==Thread.sleep(long n)== ，当前线程从 ==RUNNABLE --> TIMED_WAITING==
  - 当前线程等待时间超过了 n 毫秒或调用了线程的 **interrupt()** ，当前线程从 ==TIMED_WAITING --> RUNNABLE==
- 8、**RUNNABLE <–> TIMED_WAITING**
  - 当前线程调用 ==LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)== 时，当前线程从 ==RUNNABLE --> TIMED_WAITING==
  - 调用==LockSupport.unpark(目标线程) 或调用了线程 的 interrupt()== ，或是等待超时，会让目标线程从 ==TIMED_WAITING--> RUNNABLE==
- 9、**RUNNABLE <–> BLOCKED**
  - t 线程用 synchronized(obj) 获取了对象锁时如果==竞争失败==，从 ==RUNNABLE –> BLOCKED==, 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –> RUNNABLE ，其它失败的线程仍然 BLOCKED
- 10、 **RUNNABLE <–> TERMINATED**
  - 当前线程所有代码运行完毕，进入 TERMINATED

# 八、死锁、哲学家就餐问题、ReentrantLock (锁重入、锁超时、可中@断、公平锁、条件变量)、同步模式之顺序控制

![img](https://img-blog.csdnimg.cn/20210202223351594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

## 一、多把锁

- 小故事
- 一间大屋子有两个功能：==睡觉、学习，互不相干==。
- 现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么==并发度很低==
  - 小南获得锁之后, 学完习之后, 小女才能进来睡觉。
- **解决方法是准备多个房间==（多个对象锁）==**

```java
@Slf4j(topic = "guizy.BigRoomTest")public class BigRoomTest {    public static void main(String[] args) {        BigRoom bigRoom = new BigRoom();        new Thread(() -> bigRoom.sleep(), "小南").start();        new Thread(() -> bigRoom.study(), "小女").start();    }}@Slf4j(topic = "guizy.BigRoom")class BigRoom {    public void sleep() {        synchronized (this) {            log.debug("sleeping 2 小时");            Sleeper.sleep(2);        }    }    public void study() {        synchronized (this) {            log.debug("study 1 小时");            Sleeper.sleep(1);        }    }}
```

```java
// 相当于串行执行, 因为锁对象是整个屋子, 所以并发性很低12:16:15.952 guizy.BigRoom [小南] - sleeping 2 小时12:16:17.954 guizy.BigRoom [小女] - study 1 小时
```

- 改进让==小南, 小女==获取不同的锁即可

 ```java
@Slf4j(topic = "guizy.BigRoomTest")public class BigRoomTest {    private static final BigRoom sleepRoom = new BigRoom();    private static final BigRoom studyRoom = new BigRoom();    public static void main(String[] args) {    	// 不同对象调用        new Thread(() -> sleepRoom.sleep(), "小南").start();        new Thread(() -> studyRoom.study(), "小女").start();    }}
 ```

```java
// 因为使用的是不同的锁对象12:18:50.580 guizy.BigRoom [小女] - study 1 小时12:18:50.580 guizy.BigRoom [小南] - sleeping 2 小时
```

- **将锁的粒度细分**

- 好处，是可以==增强并发度==
- 坏处，如果一个线程需要同时获得多把锁，就==容易发生死锁==



## 二、 活跃性

- 因为某种原因，使得代码一直无法执行完毕，这样的现象叫做 **活跃性**
- 活跃性相关的一系列问题都可以用 **==ReentrantLock==** 进行解决。

### 1、死锁 (==重点==)

- 有这样的情况：一个线程需要 **同时获取多把锁**，这时就容易发生死锁

如：线程1获取A对象锁, 线程2获取B对象锁; 此时线程1又想获取B对象锁, 线程2又想获取A对象锁; 它们都等着对象释放锁, 此时就称为死锁

```java
public static void main(String[] args) {	final Object A = new Object();	final Object B = new Object();		new Thread(()->{		synchronized (A) {			try {				Thread.sleep(2000);			} catch (InterruptedException e) {				e.printStackTrace();			}			synchronized (B) {			}		}	}).start();	new Thread(()->{		synchronized (B) {			try {				Thread.sleep(1000);			} catch (InterruptedException e) {				e.printStackTrace();			}			synchronized (A) {			}		}	}).start();}
```



##### 1.2、发生死锁的必要条件 ==(重点)==

- **互斥条件**
  - 在一段时间内，==一种资源只能被一个进程所使用==
- **请求和保持条件**
  - 进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源

- **不可抢占条件**
  - 进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放

- 循环等待条件
  - 发生死锁时，必然存在一个进程——资源的循环链。

**方式一、JPS + JStack 进程ID**

- jps先找到JVM进程

- jstack 进程ID   

  - 在Java控制台中的==Terminal==中输入 **==jps==** 指令可以查看==正在运行中的进程ID==，使用 **==jstack 进程ID==** 可以查看进程状态。

  ![](/Users/qianwei/Library/Application Support/typora-user-images/image-20210622151030339.png) 



![image-20210622151344946](/Users/qianwei/Library/Application Support/typora-user-images/image-20210622151344946.png)



**方式二、 jconsole检测死锁**

![image-20210622153547957](/Users/qianwei/Library/Application Support/typora-user-images/image-20210622153547957.png)



![image-20210622153614501](/Users/qianwei/Library/Application Support/typora-user-images/image-20210622153614501.png)



##### 1.4、死锁举例 - 哲学家就餐问题 (==重点==)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201223123802724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)



有五位哲学家，围坐在圆桌旁。

- 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。
- 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。
- 如果筷子被身边的人拿着，自己就得等待

当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。

```java
/** * Description: 使用synchronized加锁, 导致哲学家就餐问题, 死锁: 核心原因是因为synchronized的锁是不可打断的, 进入阻塞队列 *                  需要一直等待别的线程释放锁 * * @author guizy1 * @date 2020/12/23 13:50 */@Slf4j(topic = "guizy.PhilosopherEat")public class PhilosopherEat {    public static void main(String[] args) {        Chopstick c1 = new Chopstick("1");        Chopstick c2 = new Chopstick("2");        Chopstick c3 = new Chopstick("3");        Chopstick c4 = new Chopstick("4");        Chopstick c5 = new Chopstick("5");        new Philosopher("苏格拉底", c1, c2).start();        new Philosopher("柏拉图", c2, c3).start();        new Philosopher("亚里士多德", c3, c4).start();        new Philosopher("赫拉克利特", c4, c5).start();        new Philosopher("阿基米德", c5, c1).start();    }}@Slf4j(topic = "guizy.Philosopher")class Philosopher extends Thread {    final Chopstick left;    final Chopstick right;    public Philosopher(String name, Chopstick left, Chopstick right) {        super(name);        this.left = left;        this.right = right;    }    @Override    public void run() {        while (true) {            // 尝试获取左手筷子            synchronized (left) {                // 尝试获取右手筷子                synchronized (right) {                    eat();                }            }        }    }    private void eat() {        log.debug("eating...");        Sleeper.sleep(0.5);    }}class Chopstick{    String name;    public Chopstick(String name) {        this.name = name;    }    @Override    public String toString() {        return "筷子{" + name + '}';    }}
```

```java
// 程序只执行了下面的打印, 没有停止, 没有打印15:04:55.346 guizy.Philosopher [苏格拉底] - eating...15:04:55.346 guizy.Philosopher [亚里士多德] - eating...15:04:55.850 guizy.Philosopher [亚里士多德] - eating...15:04:55.850 guizy.Philosopher [苏格拉底] - eating...15:04:56.351 guizy.Philosopher [亚里士多德] - eating...15:04:56.852 guizy.Philosopher [亚里士多德] - eating...
```

通过==jps, jstack 进程id==查看死锁原因

==Found one Java-level deadlock:== 发现了一个Java级别的死锁

```java
Found one Java-level deadlock:============================="阿基米德":  waiting to lock monitor 0x000000001ae2a358 (object 0x00000000d6ea7420, a com.guizy.reentrantlock.Chopstick),  which is held by "苏格拉底""苏格拉底":  waiting to lock monitor 0x0000000017fb3518 (object 0x00000000d6ea7430, a com.guizy.reentrantlock.Chopstick),  which is held by "柏拉图""柏???图":  waiting to lock monitor 0x0000000017fb3468 (object 0x00000000d6ea7440, a com.guizy.reentrantlock.Chopstick),  which is held by "亚里士多德""亚里士多德":  waiting to lock monitor 0x0000000017fb0bd8 (object 0x00000000d6ea7450, a com.guizy.reentrantlock.Chopstick),  which is held by "赫拉克利特""赫拉克利特":  waiting to lock monitor 0x0000000017fb0c88 (object 0x00000000d6ea7460, a com.guizy.reentrantlock.Chopstick),  which is held by "阿基米德"Java stack information for the threads listed above:==================================================="阿基米德":        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)        - waiting to lock <0x00000000d6ea7420> (a com.guizy.reentrantlock.Chopstick)        - locked <0x00000000d6ea7460> (a com.guizy.reentrantlock.Chopstick)"苏格拉底":        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)        - waiting to lock <0x00000000d6ea7430> (a com.guizy.reentrantlock.Chopstick)        - locked <0x00000000d6ea7420> (a com.guizy.reentrantlock.Chopstick)"柏拉图":        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)        - waiting to lock <0x00000000d6ea7440> (a com.guizy.reentrantlock.Chopstick)        - locked <0x00000000d6ea7430> (a com.guizy.reentrantlock.Chopstick)"亚里士多德":        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)        - waiting to lock <0x00000000d6ea7450> (a com.guizy.reentrantlock.Chopstick)        - locked <0x00000000d6ea7440> (a com.guizy.reentrantlock.Chopstick)"赫拉克利特":        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)        - waiting to lock <0x00000000d6ea7460> (a com.guizy.reentrantlock.Chopstick)        - locked <0x00000000d6ea7450> (a com.guizy.reentrantlock.Chopstick)Found 1 deadlock.
```

##### 1.5、避免死锁的方法

- 在线程使用锁对象时, 采用**固定加锁的顺序**, 可以使用Hash值的大小来确定加锁的先后
- 尽可能缩减加锁的范围, 等到操作共享变量的时候才加锁
- 使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)

![img](https://img-blog.csdnimg.cn/img_convert/b8a0466afe78fa85b406d66813c15c9b.png)

### 2、活锁

- ==活锁==出现在两个线程 **==互相改变对方的结束条件==**，谁也无法结束。

##### 2.1、避免活锁的方法

- 在线程执行时，中途给予 **==不同的间隔时间==**, 让某个线程先结束即可。

##### 2.2、死锁与活锁的区别

- 死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时**线程阻塞**，**停止运行**的现象。
- 活锁是因为线程间修改了对方的结束条件，而导致代码**一直在运行**，却一直**运行不完**的现象。

### 3、饥饿

- 某些线程因为优先级太低，导致一直无法获得资源的现象。
- 在使用==顺序加锁==时，可能会出现==饥饿现象==

## 三、 ReentrantLock ==(重点)==

**==ReentrantLock==** **的特点 (synchronized不具备的)**

- 支持锁重入
  - 可重入锁是指==同一个线程如果首次获得了这把锁==，那么因为它是这把==锁的拥有者==，因此 **有权利再次获取这把锁**

- 可中断
  - ==lock.lockInterruptibly()== : 可以被其他线程打断的中断锁

- 可以设置超时时间
  - ==lock.tryLock(时间)== : 尝试获取锁对象, 如果超过了设置的时间, 还没有获取到锁, 此时就退出阻塞队列, 并释放掉自己拥有的锁

- 可以设置为公平锁
  - **(先到先得) ==默认是非公平, true为公平 new ReentrantLock(true)==**

- 支持多个条件变量( **==有多个waitset==**)
  - (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用 await/signal方法, 等待/唤醒

**基本语法**

```java
//获取ReentrantLock对象private ReentrantLock lock = new ReentrantLock();//加锁lock.lock();try {	//需要执行的代码}finally {	//释放锁	lock.unlock();}
```

### ReentrantLock特点

#### 1、支持锁重入

- 可重入锁是指==同一个线程如果首次获得了这把锁==，那么因为它是这把==锁的拥有者==，因此 **有权利再次获取这把锁**
- 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住

```java
/** * Description: ReentrantLock 可重入锁, 同一个线程可以多次获得锁对象 * * @author guizy1 * @date 2020/12/23 13:50 */@Slf4j(topic = "guizy.ReentrantTest")public class ReentrantTest {    private static ReentrantLock lock = new ReentrantLock();    public static void main(String[] args) {    	// 如果有竞争就进入==阻塞队列==, 一直等待着,不能被打断        lock.lock();        try {            log.debug("entry main...");            m1();        } finally {            lock.unlock();        }    }    private static void m1() {        lock.lock();        try {            log.debug("entry m1...");            m2();        } finally {            lock.unlock();        }    }    private static void m2() {        log.debug("entry m2....");    }}
```

```java
13:54:29.324 guizy.ReentrantTest [main] - entry main...13:54:29.326 guizy.ReentrantTest [main] - entry m1...13:54:29.326 guizy.ReentrantTest [main] - entry m2....
```

#### 2、可中断 (针对于lockInterruptibly()方法获得的中断锁) 直接退出阻塞队列, 获取锁失败

> **==synchronized==** 和 **==reentrantlock.lock()==** 的锁, 是不可被打断的; 也就是说别的线程已经获得了锁, 我的线程就需要一直等待下去. 不能中断
>
> - 可被中断的锁, 通过==lock.lockInterruptibly()==获取的锁对象, 可以通过调用**阻塞线程的interrupt()方法**

- 如果==某个线程处于阻塞状态==，可以调用其==interrupt方法==让其==停止阻塞==，**获得锁失败**
  - 处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行

- 可中断的锁, 在一定程度上可以==被动==的减少==死锁==的概率, 之所以被动, 是因为我们需要手动调用==阻塞线程的interrupt==方法;

测试使用==lock.lockInterruptibly()==可以从阻塞队列中,打断

```java
/** * Description: ReentrantLock, 演示RenntrantLock中的可打断锁方法 lock.lockInterruptibly(); * */@Slf4j(topic = "guizy.ReentrantTest")public class ReentrantTest {    private static final ReentrantLock lock = new ReentrantLock();    public static void main(String[] args) {        Thread t1 = new Thread(() -> {            log.debug("t1线程启动...");            try {                // lockInterruptibly()是一个可打断的锁, 如果有锁竞争在进入阻塞队列后,可以通过interrupt进行打断                lock.lockInterruptibly();            } catch (InterruptedException e) {                e.printStackTrace();                log.debug("等锁的过程中被打断"); //没有获得锁就被打断跑出的异常                return;            }            try {                log.debug("t1线程获得了锁");            } finally {                lock.unlock();            }        }, "t1");        // 主线程获得锁(此锁不可打断)        lock.lock();        log.debug("main线程获得了锁");        // 启动t1线程        t1.start();        try {            Sleeper.sleep(1);            t1.interrupt();            //打断t1线程            log.debug("执行打断");        } finally {            lock.unlock();        }    }}
```

```java
14:18:09.145 guizy.ReentrantTest [main] - main线程获得了锁14:18:09.148 guizy.ReentrantTest [t1] - t1线程启动...14:18:10.149 guizy.ReentrantTest [main] - 执行打断14:18:10.149 guizy.ReentrantTest [t1] - 等锁的过程中被打断java.lang.InterruptedException	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)	at com.guizy.reentrantlock.ReentrantTest.lambda$main$0(ReentrantTest.java:25)	at java.lang.Thread.run(Thread.java:748)
```

测试使用==lock.lock()==不可以从阻塞队列中打断, 一直等待别的线程释放锁

```java
@Slf4j(topic = "ReentrantTest")public class ReentrantTest {    private static final ReentrantLock lock = new ReentrantLock();    public static void main(String[] args) {        Thread t1 = new Thread(() -> {            log.debug("t1线程启动...");            lock.lock();            try {                log.debug("t1线程获得了锁");            } finally {                lock.unlock();            }        }, "t1");        // 主线程获得锁(此锁不可打断)        lock.lock();        log.debug("main线程获得了锁");        // 启动t1线程        t1.start();        try {            try {                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }            t1.interrupt();            //打断t1线程            log.debug("main线程执行打断");        } finally {            log.debug("main释放锁");            lock.unlock();        }    }}
```

- **lock()锁不能被打断**, 在主线程中调用t1.interrupt(), 没用, 当主线程释放锁之后, t1获得了锁

```java
15:59:37.156 [main] DEBUG ReentrantTest - main线程获得了锁15:59:37.160 [t1] DEBUG ReentrantTest - t1线程启动...15:59:39.160 [main] DEBUG ReentrantTest - main线程执行打断15:59:39.160 [main] DEBUG ReentrantTest - main释放锁15:59:39.160 [t1] DEBUG ReentrantTest - t1线程获得了锁
```

#### 3、锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败

> **防止==无限制==等待, 减少死锁**

- 使用 **==lock.tryLock()==** 方法会==返回获取锁是否成功==。如果成功则返回true，反之则返回false。

- 并且==tryLock方法==可以设置**指定等待时间**，参数为：**==tryLock(long timeout, TimeUnit unit)==** , 其中timeout为最长等待时间，TimeUnit为时间单位

> 获取锁的过程中, 如果==超过等待时间==, ==或者被打断==, 就直接从==阻塞队列==移除, 此时获取锁就失败了, 不会一直阻塞着 ! (可以用来实现死锁问题)

- **不设置等待时间, 立即失败**

```java
/** * Description: ReentrantLock, 演示RenntrantLock中的tryLock(), 获取锁立即失败 */@Slf4j(topic = "guizy.ReentrantTest")public class ReentrantTest {    private static final ReentrantLock lock = new ReentrantLock();    public static void main(String[] args) {        Thread t1 = new Thread(() -> {            log.debug("尝试获得锁");            // 此时肯定获取失败, 因为主线程已经获得了锁对象            if (!lock.tryLock()) {                log.debug("获取立刻失败，返回");                return;            }            try {                log.debug("获得到锁");            } finally {                lock.unlock();            }        }, "t1");        lock.lock();        log.debug("获得到锁");        t1.start();        // 主线程2s之后才释放锁        Sleeper.sleep(2);        log.debug("释放了锁");        lock.unlock();    }}14:52:19.726 guizy.WaitNotifyTest [main] - 获得到锁14:52:19.728 guizy.WaitNotifyTest [t1] - 尝试获得锁14:52:19.728 guizy.WaitNotifyTest [t1] - 获取立刻失败，返回14:52:21.728 guizy.WaitNotifyTest [main] - 释放了锁
```

- **设置等待时间, 超过等待时间还没有获得锁, 失败, 从阻塞队列移除该线程**

```java
/** * Description: ReentrantLock, 演示RenntrantLock中的tryLock(long mills), 超过锁设置的等待时间,就从阻塞队列移除 * * @author guizy1 * @date 2020/12/23 13:50 */@Slf4j(topic = "guizy.ReentrantTest")public class ReentrantTest {    private static final ReentrantLock lock = new ReentrantLock();    public static void main(String[] args) {        Thread t1 = new Thread(() -> {            log.debug("尝试获得锁");            try {                // 设置等待时间, 超过等待时间 / 被打断, 都会获取锁失败; 退出阻塞队列                if (!lock.tryLock(1, TimeUnit.SECONDS)) {                    log.debug("获取锁超时，返回");                    return;                }            } catch (InterruptedException e) {                log.debug("被打断了, 获取锁失败, 返回");                e.printStackTrace();                return;            }            try {                log.debug("获得到锁");            } finally {                lock.unlock();            }        }, "t1");        lock.lock();        log.debug("获得到锁");        t1.start();//        t1.interrupt();        // 主线程2s之后才释放锁        Sleeper.sleep(2);        log.debug("main线程释放了锁");        lock.unlock();    }}// 超时的打印14:55:56.647 guizy.WaitNotifyTest [main] - 获得到锁14:55:56.651 guizy.WaitNotifyTest [t1] - 尝试获得锁14:55:57.652 guizy.WaitNotifyTest [t1] - 获取锁超时，返回14:55:58.652 guizy.WaitNotifyTest [main] - main线程释放了锁// 中断的打印14:56:41.258 guizy.WaitNotifyTest [main] - 获得到锁14:56:41.260 guizy.WaitNotifyTest [main] - main线程释放了锁14:56:41.261 guizy.WaitNotifyTest [t1] - 尝试获得锁14:56:41.261 guizy.WaitNotifyTest [t1] - 被打断了, 获取锁失败, 返回java.lang.InterruptedException
```

##### 通过==lock.tryLock()==来解决, ==哲学家就餐==问题 (==重点==)

> ==lock.tryLock(时间)== : 尝试获取锁对象, 如果超过了设置的时间, 还没有获取到锁, 此时就退出阻塞队列, 并释放掉自己拥有的锁

```java
/** * Description: 使用了ReentrantLock锁, 该类中有一个tryLock()方法, 在指定时间内获取不到锁对象, 就从阻塞队列移除,不用一直等待。 *              当获取了左手边的筷子之后, 尝试获取右手边的筷子, 如果该筷子被其他哲学家占用, 获取失败, 此时就先把自己左手边的筷子, *              给释放掉. 这样就避免了死锁问题 * * @author guizy1 * @date 2020/12/23 13:50 */@Slf4j(topic = "guizy.PhilosopherEat")public class PhilosopherEat {    public static void main(String[] args) {        Chopstick c1 = new Chopstick("1");        Chopstick c2 = new Chopstick("2");        Chopstick c3 = new Chopstick("3");        Chopstick c4 = new Chopstick("4");        Chopstick c5 = new Chopstick("5");        new Philosopher("苏格拉底", c1, c2).start();        new Philosopher("柏拉图", c2, c3).start();        new Philosopher("亚里士多德", c3, c4).start();        new Philosopher("赫拉克利特", c4, c5).start();        new Philosopher("阿基米德", c5, c1).start();    }}@Slf4j(topic = "guizy.Philosopher")class Philosopher extends Thread {    final Chopstick left;    final Chopstick right;    public Philosopher(String name, Chopstick left, Chopstick right) {        super(name);        this.left = left;        this.right = right;    }    @Override    public void run() {        while (true) {            // 获得了左手边筷子 (针对五个哲学家, 它们刚开始肯定都可获得左筷子)            if (left.tryLock()) {                try {                	// 此时发现它的right筷子被占用了, 使用tryLock(),                 	// 尝试获取失败, 此时它就会将自己左筷子也释放掉                    // 临界区代码                    if (right.tryLock()) { //尝试获取右手边筷子, 如果获取失败, 则会释放左边的筷子                        try {                            eat();                        } finally {                            right.unlock();                        }                    }                } finally {                    left.unlock();                }            }        }    }    private void eat() {        log.debug("eating...");        Sleeper.sleep(0.5);    }}// 继承ReentrantLock, 让筷子类称为锁class Chopstick extends ReentrantLock {    String name;    public Chopstick(String name) {        this.name = name;    }    @Override    public String toString() {        return "筷子{" + name + '}';    }}
```

```java
16:08:06.500 [苏格拉底] DEBUG guizy.Philosopher - eating...16:08:06.500 [亚里士多德] DEBUG guizy.Philosopher - eating...16:08:07.005 [柏拉图] DEBUG guizy.Philosopher - eating...16:08:07.005 [阿基米德] DEBUG guizy.Philosopher - eating...16:08:07.508 [苏格拉底] DEBUG guizy.Philosopher - eating...16:08:07.508 [亚里士多德] DEBUG guizy.Philosopher - eating...16:08:08.014 [苏格拉底] DEBUG guizy.Philosopher - eating...16:08:08.014 [赫拉克利特] DEBUG guizy.Philosopher - eating...16:08:08.518 [阿基米德] DEBUG guizy.Philosopher - eating...16:08:08.518 [柏拉图] DEBUG guizy.Philosopher - eating...16:08:09.022 [苏格拉底] DEBUG guizy.Philosopher - eating...16:08:09.022 [赫拉克利特] DEBUG guizy.Philosopher - eating...16:08:09.527 [赫拉克利特] DEBUG guizy.Philosopher - eating...16:08:09.527 [苏格拉底] DEBUG guizy.Philosopher - eating...16:08:10.030 [苏格拉底] DEBUG guizy.Philosopher - eating...16:08:10.030 [亚里士多德] DEBUG guizy.Philosopher - eating...16:08:10.531 [柏拉图] DEBUG guizy.Philosopher - eating...16:08:10.531 [赫拉克利特] DEBUG guizy.Philosopher - eating...16:08:11.031 [柏拉图] DEBUG guizy.Philosopher - eating...16:08:11.031 [赫拉克利特] DEBUG guizy.Philosopher - eating...16:08:11.535 [柏拉图] DEBUG guizy.Philosopher - eating...16:08:11.535 [赫拉克利特] DEBUG guizy.Philosopher - eating...
```

#### 4、公平锁 new ReentrantLock(true)

- **==ReentrantLock默认是非公平锁, 可以指定为公平锁。==**

- 在线程获取锁失败，进入阻塞队列时，**先进入**的会在锁被释放后**先获得**锁。这样的获取方式就是**公平**的。一般不设置==ReentrantLock==为公平的, 会降低==并发度==

- ==Synchronized==底层的==Monitor锁==就是不公平的, 和谁先进入==阻塞队列==是没有关系的。

  ```java
  //默认是不公平锁，需要在创建时指定为公平锁ReentrantLock lock = new ReentrantLock(true);
  ```

##### 4.1、什么是公平锁? 什么是非公平锁?

###### 公平锁 (new ReentrantLock(true))

- 公平锁, 可以把竞争的线程放在一个先进先出的阻塞队列上
- 只要持有锁的线程执行完了, 唤醒阻塞队列中的下一个线程获取锁即可; 此时先进入阻塞队列的线程先获取到锁

###### 非公平锁 (synchronized, new ReentrantLock())

- 非公平锁, 当阻塞队列中已经有等待的线程A了, 此时后到的线程B, 先去尝试看能否获得到锁对象. 如果获取成功, 此时就不需要进入阻塞队列了. 这样以来后来的线程B就先活的到锁了

>  所以公平和非公平的区别 : **==线程执行同步代码块时, 是否回去尝试获取锁==**, 如果会尝试获取锁, 那就是非公平的, 如果不会尝试获取锁, 直接进入阻塞队列, 再等待被唤醒, 那就是公平的
>
>  - 如果不进如队列呢? 线程一直尝试获取锁不就行了?
>   - 一直尝试获取锁, 在synchronized轻量级锁升级为重量级锁时, 做的一个优化, 叫做==自旋锁==, 一般很消耗资源, cpu一直空转, 最后获取锁也失败, 所以不推荐使用。在jdk6对于自旋锁有一个机制, 在重试获得锁指定次数就失败等等

#### 5、条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用==await/signal==方法, 等待/唤醒

- **==Synchronized==** 中也有==条件变量==，就是==Monitor监视器==中的 ==waitSet等待集合==，当条件不满足时进入==waitSet 等待==
- **==ReentrantLock==** 的条件变量比 synchronized 强大之处在于,它是 **==支持多个条件变量==。**

- 这就好比synchronized 是那些不满足条件的线程都在==一间休息室==等通知; **==(此时会造成虚假唤醒)==**, 而 ReentrantLock 支持==多间休息室==，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒; **==(可以避免虚假唤醒)==**

 ==**使用要点：**==

- await 前需要 **获得锁**

- await 执行后，会释放锁，进入 ==conditionObject== (条件变量)中等待

- await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁
  - 竞争 lock 锁成功后，从 await 后继续执行
- signal 方法用来唤醒==条件变量(等待室)==汇总的某一个等待的线程
- signalAll方法, 唤醒==条件变量(休息室)==中的所有线程

```java
/** * Description: ReentrantLock可以设置多个条件变量(多个休息室), 相对于synchronized底层monitor锁中waitSet */@Slf4j(topic = "guizy.ConditionVariable")public class ConditionVariable {    private static boolean hasCigarette = false;    private static boolean hasTakeout = false;    private static final ReentrantLock lock = new ReentrantLock();    // 等待烟的休息室    static Condition waitCigaretteSet = lock.newCondition();    // 等外卖的休息室    static Condition waitTakeoutSet = lock.newCondition();    public static void main(String[] args) {        new Thread(() -> {            lock.lock();            try {                log.debug("有烟没？[{}]", hasCigarette);                while (!hasCigarette) {                    log.debug("没烟，先歇会！");                    try {                        // 此时小南进入到 等烟的休息室                        waitCigaretteSet.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                log.debug("烟来咯, 可以开始干活了");            } finally {                lock.unlock();            }        }, "小南").start();        new Thread(() -> {            lock.lock();            try {                log.debug("外卖送到没？[{}]", hasTakeout);                while (!hasTakeout) {                    log.debug("没外卖，先歇会！");                    try {                        // 此时小女进入到 等外卖的休息室                        waitTakeoutSet.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                log.debug("外卖来咯, 可以开始干活了");            } finally {                lock.unlock();            }        }, "小女").start();        Sleeper.sleep(1);        new Thread(() -> {            lock.lock();            try {                log.debug("送外卖的来咯~");                hasTakeout = true;                // 唤醒等外卖的小女线程                waitTakeoutSet.signal();            } finally {                lock.unlock();            }        }, "送外卖的").start();        Sleeper.sleep(1);        new Thread(() -> {            lock.lock();            try {                log.debug("送烟的来咯~");                hasCigarette = true;                // 唤醒等烟的小南线程                waitCigaretteSet.signal();            } finally {                lock.unlock();            }        }, "送烟的").start();    }}
```

```java
15:08:58.231 guizy.WaitNotifyTest [小南] - 有烟没？[false]15:08:58.234 guizy.WaitNotifyTest [小南] - 没烟，先歇会！15:08:58.235 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]15:08:58.235 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！15:08:59.232 guizy.WaitNotifyTest [送外卖的] - 送外卖的来咯~15:08:59.233 guizy.WaitNotifyTest [小女] - 外卖来咯, 可以开始干活了15:09:00.233 guizy.WaitNotifyTest [送烟的] - 送烟的来咯~15:09:00.234 guizy.WaitNotifyTest [小南] - 烟来咯, 可以开始干活了
```



## 四、同步模式之顺序控制 (案例)

- 假如有两个线程, 线程A打印1, 线程B打印2.

- 要求: **程序先打印2, 再打印1**

### 1、Wait/Notify版本实现

```java
/** * Description: 使用wait/notify来实现顺序打印 2, 1 * * @author guizy1 * @date 2020/12/23 16:04 */@Slf4j(topic = "guizy.SyncPrintWaitTest")public class SyncPrintWaitTest {    public static final Object lock = new Object();    // t2线程释放执行过    public static boolean t2Runned = false;    public static void main(String[] args) {        Thread t1 = new Thread(() -> {            synchronized (lock) {                while (!t2Runned) {                    try {                    	// 进入等待(waitset), 会释放锁                        lock.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                log.debug("1");            }        }, "t1");        Thread t2 = new Thread(() -> {            synchronized (lock) {                log.debug("2");                t2Runned = true;                lock.notify();            }        }, "t2");        t1.start();        t2.start();    }}/** * Description: 使用wait/notify来实现交替打印 1, 2 */@Slf4j(topic = "guizy.SyncPrintWaitTest")public class SyncPrintWaitTest {    public static final Object lock = new Object();    // t2线程释放执行过    public static boolean falg = true;    public static void main(String[] args) {        Thread t1 = new Thread(() -> {            for (int i = 0; i < 5; i++) {                synchronized (lock) {                    if (!falg) {                        try {                            // 进入等待(waitset), 会释放锁                            lock.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    } else {                        log.debug("1");                        falg = false;                        lock.notifyAll();                    }                }            }        }, "t1");        Thread t2 = new Thread(() -> {            for (int i = 0; i < 5; i++) {                synchronized (lock) {                    if (falg) {                        try {                            lock.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    } else {                        log.debug("2");                        falg = true;                        lock.notify();                    }                }            }        }, "t2");        t1.start();        t2.start();    }}
```

### 2、使用ReentrantLock的await/signal

```java
/** * Description: 使用ReentrantLock的await/sinal 来实现顺序打印 2, 1 * */@Slf4j(topic = "guizy.SyncPrintWaitTest")public class SyncPrintWaitTest {    public static final ReentrantLock lock = new ReentrantLock();    public static Condition condition = lock.newCondition();    // t2线程释放执行过    public static boolean t2Runned = false;    public static void main(String[] args) {        Thread t1 = new Thread(() -> {            lock.lock();            try {                // 临界区                while (!t2Runned) {                    try {                        condition.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                log.debug("1");            } finally {                lock.unlock();            }        }, "t1");        Thread t2 = new Thread(() -> {            lock.lock();            try {                log.debug("2");                t2Runned = true;                condition.signal();            } finally {                lock.unlock();            }        }, "t2");        t1.start();        t2.start();    }}
```

### 3、使用LockSupport中的park/unpart

```java
/** * Description: 使用LockSupport中的park,unpark来实现, 顺序打印 2, 1 */@Slf4j(topic = "guizy.SyncPrintWaitTest")public class SyncPrintWaitTest {    public static void main(String[] args) {        Thread t1 = new Thread(() -> {            LockSupport.park();            log.debug("1");        }, "t1");        t1.start();        new Thread(() -> {            log.debug("2");            LockSupport.unpark(t1);        }, "t2").start();    }}
```

## 五、交替输出（案例）

需求

- **线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。现在要求输出 abcabcabcabcabcabc**

### 1、**wait/notify版本**

```java
/** * Description: 使用wait/notify来实现三个线程交替打印abcabcabcabcabc * * @author guizy1 * @date 2020/12/23 17:00 */@Slf4j(topic = "guizy.TestWaitNotify")public class TestWaitNotify {    public static void main(String[] args) {        WaitNotify waitNotify = new WaitNotify(1, 5);        new Thread(() -> {            waitNotify.print("a", 1, 2);        }, "a线程").start();        new Thread(() -> {            waitNotify.print("b", 2, 3);        }, "b线程").start();        new Thread(() -> {            waitNotify.print("c", 3, 1);        }, "c线程").start();    }}@Slf4j(topic = "guizy.WaitNotify")@Data@AllArgsConstructorclass WaitNotify {    private int flag;        // 循环次数    private int loopNumber;    /*        输出内容    等待标记    下一个标记        a           1          2        b           2          3        c           3          1     */    public void print(String str, int waitFlag, int nextFlag) {        for (int i = 0; i < loopNumber; i++) {            synchronized (this) {                while (waitFlag != this.flag) {                    try {                        this.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                System.out.print(str);                this.flag = nextFlag;                this.notifyAll();            }        }    }}
```

### 2、**await/signal版本**

```java
/** * Description: 使用await/signal来实现三个线程交替打印abcabcabcabcabc */@Slf4j(topic = "guizy.TestWaitNotify")public class TestAwaitSignal {    public static void main(String[] args) throws InterruptedException {        AwaitSignal awaitSignal = new AwaitSignal(5);        Condition a_condition = awaitSignal.newCondition();        Condition b_condition = awaitSignal.newCondition();        Condition c_condition = awaitSignal.newCondition();        new Thread(() -> {            awaitSignal.print("a", a_condition, b_condition);        }, "a").start();        new Thread(() -> {            awaitSignal.print("b", b_condition, c_condition);        }, "b").start();        new Thread(() -> {            awaitSignal.print("c", c_condition, a_condition);        }, "c").start();        Thread.sleep(1000);        System.out.println("==========开始=========");        awaitSignal.lock();        try {            a_condition.signal();  //首先唤醒a线程        } finally {            awaitSignal.unlock();        }    }}class AwaitSignal extends ReentrantLock {    private final int loopNumber;    public AwaitSignal(int loopNumber) {        this.loopNumber = loopNumber;    }    public void print(String str, Condition condition, Condition next) {        for (int i = 0; i < loopNumber; i++) {            lock();            try {                try {                    condition.await();                    //System.out.print("i:==="+i);                    System.out.print(str);                    next.signal();                } catch (InterruptedException e) {                    e.printStackTrace();                }            } finally {                unlock();            }        }    }}
```

### 3、LockSupport的park/unpark实现

```java
/** * Description: 使用park/unpark来实现三个线程交替打印abcabcabcabcabc */@Slf4j(topic = "guizy.TestWaitNotify")public class TestParkUnpark {    static Thread a;    static Thread b;    static Thread c;    public static void main(String[] args) {        ParkUnpark parkUnpark = new ParkUnpark(5);        a = new Thread(() -> {            parkUnpark.print("a", b);        }, "a");        b = new Thread(() -> {            parkUnpark.print("b", c);        }, "b");        c = new Thread(() -> {            parkUnpark.print("c", a);        }, "c");        a.start();        b.start();        c.start();        LockSupport.unpark(a);    }}class ParkUnpark {    private final int loopNumber;    public ParkUnpark(int loopNumber) {        this.loopNumber = loopNumber;    }    public void print(String str, Thread nextThread) {        for (int i = 0; i < loopNumber; i++) {            LockSupport.park();            System.out.print(str);            LockSupport.unpark(nextThread);        }    }}
```

## 六、本章小结

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201223172500153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)



![img](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/image-20210628170543866.png)

# 九、共享模型之内存

> [多线程的三大特性 (原子性、可见性、有序性)](https://blog.csdn.net/lzb348110175/article/details/103594836)

- 之前讲的==synchronized==底层==Monitor==主要关注的是==访问共享变量==时，保证临界区代码的 **==原子性==** 。下面进一步深入学习==共享变量==在多线程间的==【可见性】==问题与多条指令执行时的==【有序性】==问题

## 一、 Java 内存模型 (==重点==)

- JMM 即 ==Java Memory Model== ，它从Java层面定义了 **==主存==、==工作内存==** 抽象概念，底层对应着CPU 寄存器、缓存、硬件内存、CPU 指令优化等。JMM 体现在以下几个方面
  - **==原子性==** - 保证指令不会受 **线程上下文切换的影响**
  - **==可见性==** - 保证指令不会受 **cpu 缓存的影响 ==(JIT对热点代码的缓存优化)==**
  - **==有序性==** - 保证指令不会受 **cpu 指令并行优化的影响**

### 1、 可见性 (==重点==)

#### 概念  

   **可见性：** 是指当一个线程修改了某一个共享变量的值，其他线程不能够立即知道这个值得修改，从而导致可见性问题。

   **共享变量：**如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。

#### 1.1、退不出的循环

- 来看一个现象，==main线程==对==run变量==的==修改==对于==t线程不可见==，**导致了 t 线程无法停止**

原因:

- 增加t1线程, 对主线程更改run变量的可见性
- 一开始一直不结束, 是因为无限循环, run都是true, JIT及时编译器, 会对t1线程所执行的run变量,进行缓存, 缓存到本地工作内存. 不去访问主存中的run. 这样可以提高性能; 也可以说是JVM打到一定阈值之后, while(true)变成了一个热点代码, 所以一直访问的都是缓存到本地工作内存(局部)中的run. 当主线程修改主存中的run变量的时候,t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了. 所以一直运行. 我们为主存(成员变量)进行==volatile==修饰, 增加变量的可见性, 当主线程修改run为false, t1线程对run的值可见. 这样就可以退出循环

```java
@Slf4j(topic = "jmm")
public class JMMT1 {
  	//如果不加volatile修饰，程序会一直运行，停不下来
    static boolean run = true;

    public static void main(String[] args) {

        Thread t1 = new Thread(() ->{
            while (run){
                // 如果打印一句话
                // 此时就可以结束, 因为println方法中, 使用到了synchronized
                // synchronized可以保证原子性、可见性、有序性
                // System.out.println("123");
            }
        });
        t1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info("停下来");
        run = false;

    }
}
```

使用==synchronized==解决

```java
public class Test1 {
    static boolean run = true;
    final static Object obj = new Object();
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            // 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出
            while (run) {
                synchronized (obj) {

                }
            }
        });

        t1.start();
        Sleeper.sleep(1);
        // 当主线程获取到锁的时候, 就修改为false了
        synchronized (obj) {
            run = false;
            System.out.println("false");
        }
    }
}
```

**为什么会出现对run变量的不可见性呢呢？分析一下：**

1.==初始状态==， ==t线程==刚开始从==主内存(成员变量)==, 因为主线程sleep(1)秒, 这时候t1线程循环了好多次run的值, 超过了一定的阈值, JIT就会将主存中的run值读取到工作内存 (相当于缓存了一份, 不会去主存中读run的值了)。

<img src="https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/image-20210628170543866.png" alt="image-20210628170109698" style="zoom: 50%;" />				

2.因为t1线程频繁地从主存中读取run的值，JIT即时编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问以提高效率

<img src="https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/image-20210628170543866.png" alt="image-20210628170224729" style="zoom: 50%;" />	

3. 1 秒之后，==main线程修改了run的值, 并同步至主存==。而 t线程是从自己工作内存中的高速缓存中读取这个变量的值，**结果永远是旧值**

<img src="https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/image-20210628170543866.png" alt="image-20210628170543866" style="zoom:50%;" />

> 可见性问题，此处涉及到 **Java 内存模型(JMM)** 。

Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。

 在内存模型中，所有的变量都存储在主内存中。每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(==主内存中该变量的一份拷贝==)

**内存模型图：**

![img](https://img-blog.csdnimg.cn/20191219165007381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6YjM0ODExMDE3NQ==,size_16,color_FFFFFF,t_70)	

**JMM线程操作内存的两条基本的规定：**

> 1.关于线程与主内存：线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写
>
> 2.关于线程间工作内存：不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要经过主内存来完成。

**共享变量可见性实现的原理：**

> 线程1对共享变量的修改要想被线程2及时看到，必须要经过如下 **2个步骤**：
>
> - 把工作内存1中更新过的共享变量刷新到主内存中
> - 把内存中最新的共享变量的值更新到工作内存2中

<img src="https://img-blog.csdnimg.cn/20191219165636484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6YjM0ODExMDE3NQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" />		

**解决方式**

> **Java**语言层面支持的 **可见性实现方式**：
>
> - volatile
> - synchronized

#### 1.2、解决方法

1. 使用==volatile==（表示易变关键字的意思），它可以用来修饰==成员变量==和==静态成员变量==，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存

> 补充：volatile 可以认为是一个轻量级的锁，被 volatile 修饰的变量，汇编指令会存在于一个"lock"的前缀。在CPU层面与主内存层面，通过缓存一致性协议，加锁后能够保证写的值同步到主内存，使其他线程能够获得最新的值。（缓存一致性协议，在链接文章中有介绍到，请参考：https://blog.csdn.net/lzb348110175/article/details/103626737）

2. 使用==synchronized关键字==也有相同的效果, 在==Java内存模型==中，synchronized规定，线程在加锁时， ==先清空工作内存 → 在主内存中拷贝最新变量的副本到工作内存 → 执行完代码 → 将更改后的共享变量的值刷新到主内存中 → 释放互斥锁。==

#### 1.3、可见性 vs 原子性

前面例子体现的实际就是==可见性==，**它保证的是在多个线程之间一个线程对 volatile 变量的修改对另一个线程可见， 而不能保证原子性**。volatile用在一个写线程，多个读线程的情况, 比较合适。 上例从字节码理解是这样的：

```java
getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
putstatic run // 线程 main 修改 run 为 false， 仅此一次
getstatic run // 线程 t 获取 run false 
```

比较一下之前我们讲线程安全时举的例子：**两个线程一个 i++ 一个 i-- ，只能保证看到最新值(可见性)，不能解决指令交错(原子性)**

```java
// 假设i的初始值为0
getstatic i // 线程2-获取静态变量i的值 线程内i=0
getstatic i // 线程1-获取静态变量i的值 线程内i=0
iconst_1 // 线程1-准备常量1
iadd // 线程1-自增 线程内i=1
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1
iconst_1 // 线程2-准备常量1
isub // 线程2-自减 线程内i=-1
putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 
```

> 注意 ：**synchronized** 语句块既可以保证代码块的**原子性**，也同时保证代码块内变量的**可见性**。但缺点是 synchronized 是属于重量级操作，性能相对更低。 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？因为println方法里面有synchronized修饰。还有那个等烟的示例, 为啥没有出现可见性问题?和synchrozized是一个道理。

#### 1.4、模式之两阶段终止

> 当我们在执行线程一时，想要终止线程二，这是就需要使用==interrupt方法==来优雅的停止线程二。这是我们之前的做法

使用volatile关键字来实现两阶段终止模式

```java
public class Test1 {
    public static void main(String[] args) throws InterruptedException {

        // 下面是两个线程操作共享变量stop
        Monitor monitor = new Monitor();
        monitor.start();

        Thread.sleep(3500);
        monitor.stop();
    }
}

class Monitor {

    // private boolean stop = false; // 不会停止程序
    private volatile boolean stop = false; // 会停止程序

    /**
     * 启动监控器线程
     */
    public void start() {
        Thread monitor = new Thread(() -> {
            //开始不停的监控
            while (true) {
                if (stop) {
                    break;
                }
            }
        });
        monitor.start();
    }

    /**
     * 用于停止监控器线程
     */
    public void stop() {
        stop = true;
    }
}
```

#### 1.5、模式之 Balking (了解)

> 定义：==Balking （犹豫）模式==用在 **==一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回==。有点类似于单例。**

```java
@Slf4j(topic = "guizy.Test1")
public class Test1 {
    public static void main(String[] args) throws InterruptedException {
        Monitor monitor = new Monitor();
        monitor.start();
        monitor.start();
        monitor.start();
        Sleeper.sleep(3.5);
        monitor.stop();
    }
}

@Slf4j(topic = "guizy.Monitor")
class Monitor {

    Thread monitor;
    //设置标记，用于判断是否被终止了
    private volatile boolean stop = false;
    //设置标记，用于判断是否已经启动过了
    private boolean starting = false;
    /**
     * 启动监控器线程
     */
    public void start() {
        //上锁，避免多线程运行时出现线程安全问题
        synchronized (this) {
            if (starting) {
                //已被启动，直接返回
                return;
            }
            //启动监视器，改变标记
            starting = true;
        }
        //设置线控器线程，用于监控线程状态
        monitor = new Thread(() -> {
            //开始不停的监控
            while (true) {
                if(stop) {
                    log.debug("处理后续儿事");
                    break;
                }
                log.debug("监控器运行中...");
                try {
                    //线程休眠
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    log.debug("被打断了...");
                }
            }
        });
        monitor.start();
    }

    /**
     * 	用于停止监控器线程
     */
    public void stop() {
        //打断线程
        stop = true;
        monitor.interrupt();
    }
}
```

### 2、 有序性 (==重点==)

> [多线程----有序性](https://blog.csdn.net/lzb348110175/article/details/103626737)

是JIT即时编译器的优化, 可能会导致指令重排。为什么要优化? 因为CPU 支持多级指令流水线，例如支持同时执行 ==取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回== 的处理器。效率快 ~

> 所谓有序性，是指程序在执行过程中的先后顺序，由于Java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。

**实例**

```java
int x = 10;
int y = 0;
x++;
y = 20;
```

​		上面这段代码定义了两个 int 类型的变量 x 和 y，对 x 进行自增操作，对 y 进行赋值操作，从编写程序的角度来看上面的代码肯定是顺序执行下来的，但是在 JVM 真正地运行这段代码的时候未必会是这样的顺序，比如 y=20 语句有可能会在 x++ 语句的前面得到执行，这种情况就是我们通常所说的 ==**指令重排序**==

​		一般来说，处理器为了提高程序的运行效率，可能会对输入的代码指令做一定的优化，它不会百分之百的保证代码的执行顺序严格按照编写代码中的顺序来进行，但是它会保证程序的最终运算结果是编码时所期望的那样，比如上文中 x++ 与 y=20 不管它们的执行顺序如何，执行完上面的四行代码之后得到的结果肯定都是 x=11，y=20。

​		==**指令重排序原则**==：保证不影响代码执行语义的前提下，实现重排序，从而提升运行效率。当然对指令的重排序要严格遵守指令之间的数据依赖关系，并不是可以任意进行重排序的。

补充：

**==JVM==会在不影响正确性的前提下**，==可以调整语句的执行顺序==, 是一种优化

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201224225308100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

这种特性称之为==『指令重排』==, **==多线程下『指令重排』会影响正确性。==**

#### 2.1、支持流水线的处理器

现代 CPU 支持==多级指令流水线==，例如支持同时执行 ==取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回== 的处理器，就可以称之为**五级指令流水线**。**这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1**，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地==吞吐率==。

<img src="https://img-blog.csdnimg.cn/20201224232242688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" />

**在多线程环境下，指令重排序可能导致出现意料之外的结果**

#### 2.2、诡异的结果

```java
int num = 0;

// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序
boolean ready = false; 

// 线程1 执行此方法
public void actor1(I_Result r) {
	 if(ready) {
	 	r.r1 = num + num;
	 } 
	 else {
	 	r.r1 = 1;
	 }
}
// 线程2 执行此方法
public void actor2(I_Result r) {
	 num = 2;
	 ready = true;
}
```

线程1执行actor1方法, 线程2执行actor2方法

I_Result 是一个对象，有一个属性 r1 用来保存结果，问可能的结果有几种？

- 情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 ==1==
- 情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为==1==
- 情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为==4==（因为 num 已经执行过了）
- ==情况4==：==结果还有可能是 0=== ，这种情况下是：**==线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2。==**

**==情况4==**这种现象叫做==指令重排==，是==JIT 编译器在运行时的一些优化==，这个现象需要通过大量测试才能复现，可以使用==jcstress工具==进行测试。上面仅是从代码层面体现出了==有序性==问题，下面在讲到 ==double-checked locking (双重检查锁)==问题时还会从java字节码的层面了解有序性的问题。

```java
@JCStressTest
@Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
@Outcome(id = "0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
@State
public class ConcurrencyTest {

    int num = 0;
    //boolean ready = false;
    volatile boolean ready = false; // 不会发生指令重排,也就不会出现结果为0的情况
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }

    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201224234756734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)	

![img](https://img-blog.csdnimg.cn/20201224234810568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)==

确实出现了上面的结果。

#### 2.3、**重排序也需要遵守一定规则：**

1. ==指令重排序操作==不会对存在==数据依赖关系的操作==进行重排序。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
2. 重排序是为了==优化性能==，但是不管怎么重排序，单线程下程序的执行结果不能被改变。 比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。

**==指令重排序 在 单线程模式下是一定会保证最终结果的正确性==，** 但是在多线程环境下，问题就出来了。

**解决方法：==volatile 修饰的变量，可以禁用指令重排==**

> 注意：
>
> - 使用==synchronized并不能解决有序性==问题，**但是如果是该==变量==整个都在synchronized代码块的保护范围内**，那么变量就不会被多个线程同时操作，也不用考虑有序性问题！在这种情况下相当于解决了重排序问题！
> - 参考下面double-checked locking 问题里的代码，第一个代码片段中的instance变量都在synchronized代码块中，第二个代码片段中instance不全在synchronized中所以产生了问题。

#### 2.4、volatile 原理 (==重点==)

[volatile关键词解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

volatile 的底层实现原理是==内存屏障，Memory Barrier（Memory Fence）==

- 对 volatile 变量的==写指令后==会加入==写屏障==。(保证写屏障之前的写操作, 都能同步到主存中)
- 对 volatile 变量的==读指令前==会加入==读屏障==。(保证读屏障之后的读操作, 都能读到主存的数据)

####  2.5、volatile是如何保证可见性 (==重点==)

- **==写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中==**

  ```java
  public void actor2(I_Result r) {
       num = 2;
       ready = true; // ready是被volatile修饰的 ，赋值带写屏障
       // 写屏障.(在ready=true写指令之后加的, 
       //在该屏障之前对共享变量的改动, 都同步到主存中. 包括num)
  }
  ```

- **==读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据==**

  ```java
  public void actor1(I_Result r) {
  	 // 读屏障
  	 //  ready是被volatile修饰的 ，读取值带读屏障
  	 if(ready) {	// ready, 读取的就是主存中的新值
  	 	r.r1 = num + num; // num, 读取的也是主存中的新值
  	 } else {
  	 	r.r1 = 1;
  	 }
  }
  ```

  ![1594698374315](https://img-blog.csdnimg.cn/img_convert/b17feb2d8cc0907ddee8b08949a44d0d.png)

#### 2.6、volatile是如何保证有序性

- ==写屏障==会确保**指令重排序**时，**不会将写屏障之前的代码排在写屏障之后**

```java
public void actor2(I_Result r) {
 num = 2;
 ready = true; //  ready是被volatile修饰的 ， 赋值带写屏障
 // 写屏障
}
```

- 读屏障会确保指令重排序时，**不会将读屏障之后的代码排在读屏障之前**

```java
public void actor1(I_Result r) {
	 // 读屏障
	 //  ready是被volatile修饰的 ，读取值带读屏障
	 if(ready) {
	 	r.r1 = num + num;
	 } else {
	 	r.r1 = 1;
	 }
}
```

![1594698559052](https://img-blog.csdnimg.cn/img_convert/98518f6441a448a9a6ef441ef2518c83.png)	



**volatile不能解决指令交错 (==不能解决原子性==)：**

- ==写屏障仅仅是保证之后的读能够读到最新的结果==，但不能保证其它线程的读, 跑到它前面去
- **==有序性的保证也只是保证了本线程内相关代码不被重排序==**

下图t2线程, 就先读取了i=0, 此时还是会出现指令交错的现象, 可以使用==synchronized==来解决原子性

<img src="https://img-blog.csdnimg.cn/img_convert/1e8fff6923548db93e27ac4a947633e9.png" style="zoom:67%;" />==

#### 2.7、 double-checked locking (双重检查锁) 问题 (==重点==)

> 首先synchronized可以保证它的临界区的资源是 ==原子性、可见性、有序性==的, 有序性的前提是, **在synchronized代码块中的共享变量, 不会在代码块外使用到, 否则==有序性==不能被保证**, 只能使用==volatile==来保证有序性
>
> - **下面代码的第二个==双重检查==单例, 就出现了这个问题(在synchronized外使用到了INSTANCE), 此时synchronized就不能防止==指令重排==, 确保不了指令的==有序性==.**

- 以著名的==double-checked locking(双重检查锁) 单例模式==为例，这是volatile最常使用的地方。

```java
// 最开始的单例模式是这样的
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    public static Singleton getInstance() {
	    /*
	      多线程同时调用getInstance(), 如果不加synchronized锁, 此时两个线程同时
	      判断INSTANCE为空, 此时都会new Singleton(), 此时就破坏单例了.所以要加锁,
	      防止多线程操作共享资源,造成的安全问题
	     */
	    synchronized(Singleton.class) {
	    	if (INSTANCE == null) { // t1
	    		INSTANCE = new Singleton();
	        }
	    }
        return INSTANCE;
    }
}


/*
	首先上面代码的效率是有问题的, 因为当我们创建了一个单例对象后, 又来一个线程获取到锁了,还是会加锁, 
	严重影响性能,再次判断INSTANCE==null吗, 此时肯定不为null, 然后就返回刚才创建的INSTANCE;
	这样导致了很多不必要的判断; 

	所以要双重检查, 在第一次线程调用getInstance(), 直接在synchronized外,判断instance对象是否存在了,
	如果不存在, 才会去获取锁,然后创建单例对象,并返回; 第二个线程调用getInstance(), 会进行
	if(instance==null)的判断, 如果已经有单例对象, 此时就不会再去同步块中获取锁了. 提高效率
*/
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    public static Singleton getInstance() {
        if(INSTANCE == null) { // t2
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized(Singleton.class) {
                if (INSTANCE == null) { // t1
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
//但是上面的if(INSTANCE == null)判断代码没有在同步代码块synchronized中，
// 不能享有synchronized保证的原子性、可见性、以及有序性。所以可能会导致 指令重排
```

以上的实现特点是：

- 懒汉式单例
- 首次使用 getInstance() 才使用 synchronized 加锁，**后续使用时无需加锁 (也就是上面的第二个单例)**
- 有隐含的: 但很关键的一点：==第一个 if 使用了 INSTANCE 变量，是在同步块之外==, 这样会导致==synchronized==无法保证指令的==有序性==, 此时可能会导致==指令重排==问题

> **注意**: 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为

```java
0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull 37 // 判断是否为空
// ldc是获得类对象
6: ldc #3 // class cn/itcast/n5/Singleton
// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份
8: dup
// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中
// 将类对象的引用地址存储了一份，是为了将来解锁用
9: astore_0
10: monitorenter
11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull 27
// 新建一个实例
17: new #3 // class cn/itcast/n5/Singleton
// 复制了一个实例的引用
20: dup
// 通过这个复制的引用调用它的构造方法
21: invokespecial #4 // Method "<init>":()V
// 最开始的这个引用用来进行赋值操作
24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn
```

**其中**

- 17 表示创建对象，将对象引用入栈 // new Singleton
- 20 表示复制一份对象引用 // 复制了引用地址, 解锁使用
- 21 表示利用一个对象引用，调用构造方法 // 根据复制的引用地址调用构造方法
- 24 表示利用一个对象引用，赋值给 static INSTANCE

可能jvm 会优化为：==先执行 24(赋值)，再执行 21(构造方法)==。如果两个线程 t1，t2 按如下时间序列执行：

- 通过上面的字节码发现, 这一步==INSTANCE = new Singleton();==操作不是一个==原子操作==, 它分为==21, 24两个指令==, 此时可能就会发生==指令重排==的问题

  ![1594701748458](https://img-blog.csdnimg.cn/img_convert/702a41b984561f85cab618621b824079.png)

- 关键在于 ==0: getstatic== 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值

- 这时 ==t1 还未完全将构造方法==执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例 **对 INSTANCE 使用 volatile 修饰**即可，可以==禁用指令重排。==

- 注意在 JDK 5 以上的版本的 volatile 才会真正有效

##### double-checked locking 关于指令重排的解决

- 加volatile

```java
public final class Singleton {
    private Singleton() { }
    private static volatile Singleton INSTANCE = null;
    public static Singleton getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            synchronized (Singleton.class) { // t2
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) { // t1
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

字节码上看不出来 volatile 指令的效果

```java
// -------------------------------------> 加入对 INSTANCE 变量的读屏障
0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull 37
6: ldc #3 // class cn/itcast/n5/Singleton
8: dup
9: astore_0
10: monitorenter -----------------------> 保证原子性、可见性
11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull 27
17: new #3 // class cn/itcast/n5/Singleton
20: dup
21: invokespecial #4 // Method "<init>":()V
24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
// -------------------------------------> 加入对 INSTANCE 变量的写屏障
27: aload_0
28: monitorexit ------------------------> 保证原子性、可见性
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn
```

- 如上面的注释内容所示，**==读写 volatile 变量操作（即getstatic操作和putstatic操作）时会加入内存屏障（Memory Barrier（Memory Fence））==**，保证下面两点：

1. ==可见性==
   - **写屏障（sfence）**保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中
   - **读屏障（lfence）**保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据
2. ==有序性==
   1. **写屏障** 会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
   2. **读屏障** 会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前
3. **更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性**

加上==volatile==之后, 保证了==指令的有序性==, 不会发生指令重排, 21就不会跑到24之后执行了

<img src="https://img-blog.csdnimg.cn/img_convert/dd32cd4090a29b5dbd4c6a0bd8945187.png" alt="1594703228878" style="zoom:80%;" />	

==synchronized== 既能保证**原子性、可见性、有序性**，==其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作）==，上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。

> 对共享变量加==volatile==关键字可以保证==可见性==和==有序性==，但是**不能保证原子性**（即不能防止指令交错）。

#### 2.8、appens-before (==对共享变量的写操作,对其它线程的读操作可见==)

happens-before 规定了==对共享变量的写操作,对其它线程的读操作可见==，它是可见性与有序性的一套规则总结。**抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见。**

下面说的变量都是指 *==成员变量或静态成员变量==*

方式一 :

线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的 读可见

- synchronized锁, 保证了==可见性==

```java
	static int x;
	
	static Object m = new Object();
	
	new Thread(()->{
	    synchronized(m) {
	        x = 10;
	    }
	},"t1").start();
	
	new Thread(()->{
	    synchronized(m) {
	        System.out.println(x);
	    }
	},"t2").start();

// 10
```

方式二 :

线程对 **volatile 变量的写，对接下来其它线程对该变量的读可见**

- **volatile修饰的变量, 通过==写屏障==, 共享到主存中, 其他线程通过==读屏障==, 读取主存的数据**

```java
  volatile static int x;
  
  new Thread(()->{
   	x = 10;
  },"t1").start();
  
  new Thread(()->{
   	System.out.println(x);
  },"t2").start();
```

方式三:

**线程 start() 前对变量的写，对该线程开始后对该变量的读可见**

- 线程还没启动时, 修改变量的值, 在启动线程后, 获取的变量值, 肯定是修改过的

```java
  static int x;
  x = 10;
  
  new Thread(()->{
   	System.out.println(x);
  },"t2").start();
```

方式四 :

- 线程结束前 对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）
  - 主线程获取的x值, 是线程执行完对x的写操作之后的值。

```
  static int x;
  
  Thread t1 = new Thread(()->{
   	x = 10;
  },"t1");
  t1.start();
  
  t1.join();
  System.out.println(x);
```

方式五 :

- 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后, 对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）

  ```java
    static int x;
    public static void main(String[] args) {
        Thread t2 = new Thread(()->{
            while(true) {
                if(Thread.currentThread().isInterrupted()) {
                    System.out.println(x); // 10, 打断了, 读取的也是打断前修改的值
                    break;
                }
            }
        },"t2");
        t2.start(); 
        
        new Thread(()->{
            sleep(1);
            x = 10;
            t2.interrupt();
        },"t1").start();
        
        while(!t2.isInterrupted()) {
            Thread.yield();
        }
        System.out.println(x);	// 10
    }
  ```

  方式六 :

  - 对==变量默认值（0，false，null）的写==，对其它线程对该变量的 读可见 (最基本)

  - ==具有传递性==，如果 x hb-> y 并且 y hb-> z 那么有 x hb-> z ，**==配合 volatile 的防指令重排==，有下面的例子**

  - 因为==x加了volatile==, 所以在volatile static int x 代码的上面添加了==读屏障==, 保证读到的x和y的变化是可见的(包括y, 只要是读屏障下面都OK); 通过传递性, t2线程对x,y的写操作, 都是可见的

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201225130434693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)	

  #### 总结

- ==volatile==主要用在==一个线程改,多个线程读时的来保证可见性==，和==double-checked locking模式中保证synchronized代码块外的共享变量的==指令重排序==问题==

### 3、习题

#### 1、balking 模式习题

希望 **doInit() 方法仅被调用一次**，下面的实现是否有问题，为什么？

> 有问题: volatile无法保证原子性; 当多个线程同时调用init()方法时, 此时都进入到if判断, 因为都为false, 所以都调用==doInit()==方法, 此时就调用了多次
>
> - 解决方法: 对init()方法的方法体, 通过==synchronized==加锁, 防止多个线程访问共享资源导致的安全问题;

```java
public class TestVolatile {
    volatile boolean initialized = false;
    void init() {
        if (initialized) {
            return;
        }
        doInit();
        initialized = true;
    }
    private void doInit() {
    }
} 
```

修改后

```java
public class BigRoomTest {

    volatile static boolean initialized = false;
    final static Object obj = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            init();
        }, "t1").start();

        new Thread(() -> {
            init();
        }, "t2").start();
    }

    static void init() {
        synchronized (obj) {
            if (initialized) {
                return;
            }
            doInit();
            initialized = true;
        }
    }

    private static void doInit() {
        log.debug("init...");
    }
}
```

#### 2、线程安全单例模式 (==重点==)

单例模式有很多实现方法，==饿汉、懒汉、静态内部类、枚举类==，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题

> ==饿汉式==：**类加载就会导致该单实例对象被创建**
>
> ==懒汉式==：**类加载不会导致该单实例对象被创建，而是==首次使用该对象时才会创建==**

实现1： 饿汉式

```java
// 问题1：为什么加 final，防止子类继承后更改
// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示
public final class Singleton implements Serializable {
    // 问题3：为什么设置为私有? 放弃其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。
    private Singleton() {}
    // 问题4：这样初始化是否能保证单例对象创建时的线程安全?没有，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性
    private static final Singleton INSTANCE = new Singleton();
    // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。
    //1.提供更好的封装性；2.提供范型的支持
    public static Singleton getInstance() {
        return INSTANCE;
    }
    public Object readResolve() {
        return INSTANCE;
    }
}
```

- 问题1 : 加==final==为了防止有子类, 因为子类可以重写父类的方法
- 问题2 : 首先通过反序列化操作, 也是可以创建一个对象的, 破坏了单例, 可以使用==readResolve==方法并返回instance对象, 当反序列化的时候就会调用自己写的readResolve方法
- 问题3 : 私有化构造器, 防止外部通过构造器来创建对象; 但不能防止反射来创建对象
- 问题4 : 因为单例对象是==static==的, 静态成员变量的初始化操作是在==类加载阶段完成==, 由JVM保证其线程安全 ==(这其实是利用了ClassLoader的线程安全机制。ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。)==
- 问题5 : 通过向外提供公共方法, 体现了更好的封装性, 可以在方法内实现==懒加载==的单例; 可以提供泛型等
- 补充 : ==任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。==

实现2： 饿汉式: 因为枚举的变量, 底层是通过public static final来修饰的, 类加载就创建了,所以是饿汉式

```java
// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量
// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量
// 问题3：枚举单例能否被反射破坏单例：不能
// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例
// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了
enum Singleton {
 INSTANCE;
}
```

实现3：懒汉式

```java
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    // 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大.
    public static synchronized Singleton getInstance() {
        if( INSTANCE != null ){
            return INSTANCE;
        }
        INSTANCE = new Singleton();
        return INSTANCE;
    }
}
```

上面是一个懒汉式的单例, 代码存在性能问题: 当单例对象已经创建好了, 多个线程访问==getInstance()==方法, 仍然会获取锁, 同步操作, 性能很低, 此时出现==重复判断==, 因此要使用==双重检查==

实现4：DCL 懒汉式

```java
public final class Singleton {
    private Singleton() { }
    // 问题1：解释为什么要加 volatile ?为了防止重排序问题
    private static volatile Singleton INSTANCE = null;

    // 问题2：对比实现3, 说出这样做的意义：提高了效率
    public static Singleton getInstance() {
        if (INSTANCE != null) {
            return INSTANCE;
        }
        synchronized (Singleton.class) {
            // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。
            if (INSTANCE != null) { // t2
                return INSTANCE;
            }
            INSTANCE = new Singleton();
            return INSTANCE;
        }
    }
}
```

> - 问题1 : 因为在synchronized外部使用到了共享变量INSTANCE, 所以synchronized无法保证instance的有序性, 又因为==instance = new Singleton()==不是一个原子操作, 可分为多个指令. 此时通过指令重排==, 可能会造成INSTANCE还未初始化, 就赋值的现象, 所以要给共享变量INSTANCE加上volatile,==禁止指令重排
>
> - 问题2 : 增加了==双重判断==, 如果存在了单例对象, 别的线程再进来就==无需加锁判断==, 大大提高性能
> - 问题3 : 防止多线程并发导致不安全的问题:==防止单例对象被重复创建==. **当t1,t2线程都调用getInstance()方法, 它们都判断单例对象为空, 还没有创建**;
>   - 此时t1先获取到锁对象, 进入到synchronized中, 此时创建对象, 返回单例对象, 释放锁;
>   - 这时候t2获得了锁对象, 如果在代码块中没有if判断, 则线程2认为没有单例对象, 因为在代码块外判断的时候就没有, 所以t2就还是会创建单例对象. 此时就重复创建了

实现5：懒汉式

```java
public final class Singleton {
    private Singleton() { }
    // 问题1：属于懒汉式还是饿汉式：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。
    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }
    // 问题2：在创建时是否有并发问题，这是线程安全的，类加载时，jvm保证类加载操作的线程安全
    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

- 问题 1 : 懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。==静态内部类不会随着外部类的加载而加载, 这是静态内部类和静态变量的区别==
- 问题 2 : 不会有并发问题, 因为是通过类加载创建的单例, JVM保证不会出现线程安全。

## 二、本章小结

本章重点讲解了 JMM 中的

- 可见性 - 由 JVM 缓存优化引起; ==(JIT即时编译器, 通过对热点代码的优化)==
- 有序性 - 由 JVM ==指令重排序优化==引起; ==(提高指令的执行效率, 类似流水线系统)==
- happens-before 规则; ==(happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结。)==

原理方面

- volatile (读写屏障)

模式方面

- 两阶段终止模式的 volatile 改进
- 同步模式之 balking (犹豫模式)

# 十、共享模型之无锁

> - Java中 **synchronized** 和 **ReentrantLock** 等 独占锁 就是 **==悲观锁==** 思想的实现
> - 在Java中**java.util.concurrent.atomic包下面的原子变量类**就是使用了==乐观锁==的一种实现方式 **==CAS==** 实现的

==管程==即==monitor==是==阻塞式的悲观锁==实现==并发控制==，这章我们将通过==非阻塞式的乐观锁==的来实现==并发控制==

## 1、 问题提出

有如下需求，保证==account.withdraw取款方法==的线程安全, 下面使用==synchronized==保证线程安全

```java
/**
 * Description: 使用重量级锁synchronized来保证多线程访问共享资源发生的安全问题
 */
public class Test1 {

    public static void main(String[] args) {
        Account.demo(new AccountUnsafe(10000));
        Account.demo(new AccountCas(10000));
    }
}

class AccountUnsafe implements Account {
    private Integer balance;

    public AccountUnsafe(Integer balance) {
        this.balance = balance;
    }

    @Override
    public Integer getBalance() {
        synchronized (this) {
            return balance;
        }
    }

    @Override
    public void withdraw(Integer amount) {
        // 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题
        synchronized (this) {
            balance -= amount;
        }
    }
}


interface Account {
    // 获取余额
    Integer getBalance();

    // 取款
    void withdraw(Integer amount);

    /**
     * Java8之后接口新特性, 可以添加默认方法
     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
     * 如果初始余额为 10000 那么正确的结果应当是 0
     */
    static void demo(Account account) {
        List<Thread> ts = new ArrayList<>();
        long start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            ts.add(new Thread(() -> {
                account.withdraw(10);
            }));
        }
        ts.forEach(thread -> thread.start());
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        long end = System.nanoTime();
        System.out.println(account.getBalance()
                + " cost: " + (end - start) / 1000_000 + " ms");
    }
}
```

## 2、解决思路-无锁

上面的代码中使用==synchronized加锁==操作来==保证线程安全==，但是 **synchronized加锁操作太耗费资源 (因为底层使用了操作系统mutex指令, 造成内核态和用户态的切换)**，这里我们使用 **==无锁==** 来解决此问题

```java
class AccountCas implements Account {
	//使用原子整数: 底层使用CAS+重试的机制
	private AtomicInteger balance;

	public AccountCas(int balance) {
		this.balance = new AtomicInteger(balance);
	}

	@Override
	public Integer getBalance() {
		//得到原子整数的值
		return balance.get();
	}

	@Override
	public void withdraw(Integer amount) {
		while(true) {
			//获得修改前的值
			int prev = balance.get();
			//获得修改后的值
			int next = prev - amount;
			//比较并设置值
			/*
				此时的prev为共享变量的值, 如果prev被别的线程改了.也就是说: 自己读到的共享变量的值 和 共享变量最新值 不匹配,
				就继续where(true),如果匹配上了, 将next值设置给共享变量.
				
				AtomicInteger中value属性, 被volatile修饰, 就是为了确保线程之间共享变量的可见性.
			*/
			if(balance.compareAndSet(prev, next)) {
				break;
			}
		}
	}
}

```

## 3、 CAS 与 volatile ==(重点)==

使用原子操作来保证线程访问共享资源的安全性, cas+重试的机制来确保(乐观锁思想), 相对于悲观锁思想的==synchronized,reentrantLock==来说, cas的方式效率会更好!

### 3.1、cas + 重试 的原理

- 前面看到的==AtomicInteger==的解决方法，内部并==没有用锁==来保护==共享变量==的线程安全。那么它是如何实现的呢？

```java
@Override
public void withdraw(Integer amount) {
    // 核心代码
    // 需要不断尝试，直到成功为止
    while (true){
        // 比如拿到了旧值 1000
        int prev = balance.get();
        // 在这个基础上 1000-10 = 990
        int next = prev - amount;
        /*
         compareAndSet 保证操作共享变量安全性的操作:
         ① 线程A首先获取balance.get(),拿到当前的balance值prev
         ② 根据这个prev值 - amount值 = 修改后的值next
         ③ 调用compareAndSet方法, 首先会判断当初拿到的prev值,是否和现在的
         	balance值相同;
         	3.1、如果相同,表示其他线程没有修改balance的值, 此时就可以将next值
         		设置给balance属性
         	3.2、如果不相同,表示其他线程也修改了balance值, 此时就设置next值失败, 
				然后一直重试, 重新获取balance.get()的值,计算出next值,
				并判断本次的prev和balnce的值是否相同...重复上面操作
		*/
        if (atomicInteger.compareAndSet(prev,next)){
            break;
        }
    }
}
```

- 其中的关键是 ==compareAndSwap（比较并设置值）==，它的简称就是 ==CAS== （也有 Compare And Swap 的说法），它必须是==原子操作==。

  ![1594776811158](https://img-blog.csdnimg.cn/img_convert/436a166f7e783537464879edf14ccc0c.png)	

**流程 :**

 当一个线程要去修改==Account对象==中的值时，==先获取值prev（调用get方法）==，然后再将其设置为新的值==next==（调用cas方法）。在调用cas方法时，会将==prev==与==Account中的余额==进行比较。

- 如果两者==相等==，就说明该值还未被其他线程修改，此时便可以进行修改操作。
- 如果两者==不相等==，就不设置值，重新获取值prev（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。

**注意 :**

- 其实 ==CAS== 的底层是 **lock cmpxchg** 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证==【比较-交换】==的 **==原子性==**。
- 在多核状态下，某个核执行到带 lock 的指令时，**CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210202190842397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

### 3.2、volatile的作用

在上面代码中的==AtomicInteger类==，**保存值的==value属性==使用了==volatile 修饰==**。获取共享变量时，为了==保证该变量的可见性==，需要使用 **volatile 修饰**。

volatile可以用来修饰 **==成员变量和静态成员变量==**，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。**==即一个线程对 volatile 变量的修改，对另一个线程可见。==**

> ```
> 注意:== volatile 仅仅保证了共享变量的==可见性==，让其它线程能够看到最新值，==但不能解决指令交错问题（不能保证原子性）
> ```

 **CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果**

### 3.3、为什么CAS+重试(无锁)效率高

 **==使用CAS+重试---无锁==情况下，即使==重试失败==，线程始终在高速运行，没有停歇，而 ==synchronized==会让线程在没有获得锁的时候，==发生上下文切换，进入阻塞==。**

>  打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大

但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。

### 3.4、CAS 的特点 (乐观锁和悲观锁的特点)

结合 ==CAS 和 volatile== 可以实现==无锁并发==，适用于==线程数少、多核 CPU== 的场景下。

- ==CAS== 是基于==乐观锁==的思想：**最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。**
- ==synchronized== 是基于==悲观锁==的思想：**最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。**
- CAS 体现的是==无锁并发、无阻塞并发==，请仔细体会这两句话的意思
  - 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
  - 但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，**反而效率会受影响**

## 4、原子整数 (内部通过CAS来实现-AtomicInteger)

==java.util.concurrent.atomic并发包==提供了一些并发工具类，这里把它分成五类：

使用原子的方式 **(共享数据为基本数据类型原子类)**

- **==AtomicInteger：整型原子类==**
- AtomicLong：长整型原子类
- AtomicBoolean ：布尔型原子类

上面三个类提供的方法几乎相同，所以我们将以 ==AtomicInteger==为例子来介绍。

先讨论==原子整数类==，以 ==AtomicInteger== 为例讨论它的api接口：通过观察源码可以发现

- **AtomicInteger 内部都是通过==cas的原理==来实现的**

```java
public static void main(String[] args) {
    AtomicInteger i = new AtomicInteger(0);
    
    // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
    System.out.println(i.getAndIncrement());
    
    // 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
    System.out.println(i.incrementAndGet());
    
    // 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
    System.out.println(i.decrementAndGet());
    
    // 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
    System.out.println(i.getAndDecrement());
    
    // 获取并加值（i = 0, 结果 i = 5, 返回 0）
    System.out.println(i.getAndAdd(5));
    
    // 加值并获取（i = 5, 结果 i = 0, 返回 0）
    System.out.println(i.addAndGet(-5));
    
    // 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）
    // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
    System.out.println(i.getAndUpdate(p -> p - 2));
    
    // 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）
    // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
    System.out.println(i.updateAndGet(p -> p + 2));
    
    // 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）
    // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
    // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的
    // getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final
    System.out.println(i.getAndAccumulate(10, (p, x) -> p + x));
    
    // 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）
    // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
    System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x));
}
```

#### 举个例子: updateAndGet的实现

```java
public static void main(String[] args) {

	AtomicInteger i = new AtomicInteger(5);
	
    updateAndGet(i, new IntUnaryOperator() {
        @Override
        public int applyAsInt(int operand) {
            return operand / 2;
        }
    });
    System.out.println(i.get()); // 2
}

public static void updateAndGet(AtomicInteger i, IntUnaryOperator operator) {
    while (true) {
        int prev = i.get(); // 5
        int next = operator.applyAsInt(prev);
        if (i.compareAndSet(prev, next)) {
            break;
        }
    }
}
```

步骤:

- 调用==updateAndGet==方法, 将==共享变量i==, ==IntUnaryOperator对象==传递过去

- updateAndGet方法内部, 传过来的==operator==对象, 调用==IntUnaryOperator中的applyAsInt==方法, 实际调用的就是==传递过来的对象的方法, 进行 / 操作==

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227190220505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)	



## 5、原子引用 (AtomicReference)

原子引用的作用: **保证引用类型的共享变量是线程安全的(确保这个原子引用没有引用过别人)**

为什么需要原子引用类型 ? (引用数据类型原子类)

- ==AtomicReference==
- ==AtomicMarkableReference==
- ==AtomicStampedReference== **(可以解决ABA问题)**

为什么需要==原子引用类型==？**保证==引用类型的共享变量是线程安全==的（确保这个原子引用没有引用过别人）。**

基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。

-  **AtomicReference**：引用类型原子类

-  **AtomicStampedReference**：原子更新带有==版本号==的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，**==可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。==**
-  **AtomicMarkableReference** ：原子更新带有==标记==的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

例子 : 使用原子引用实现BigDecimal存取款的线程安全：

下面这个是不安全的实现过程：

```java
class DecimalAccountUnsafe implements DecimalAccount {
    BigDecimal balance;
    public DecimalAccountUnsafe(BigDecimal balance) {
        this.balance = balance;
    }
    @Override
    public BigDecimal getBalance() {
        return balance;
    }
    @Override
    public void withdraw(BigDecimal amount) {
        BigDecimal balance = this.getBalance();
        this.balance = balance.subtract(amount);
    }
}
```

解决代码如下：在==AtomicReference类==中，存在一个value类型的变量，保存对BigDecimal对象的引用。

```java
public class Test1 {

    public static void main(String[] args) {
        DecimalAccount.demo(new DecimalAccountCas(new BigDecimal("10000")));
    }
}

class DecimalAccountCas implements DecimalAccount {

    //原子引用，泛型类型为小数类型
    private final AtomicReference<BigDecimal> balance;

    public DecimalAccountCas(BigDecimal balance) {
        this.balance = new AtomicReference<>(balance);
    }

    @Override
    public BigDecimal getBalance() {
        return balance.get();
    }

    @Override
    public void withdraw(BigDecimal amount) {
        while (true) {
            BigDecimal prev = balance.get();
            BigDecimal next = prev.subtract(amount);
            if (balance.compareAndSet(prev, next)) {
                break;
            }
        }
    }
}


interface DecimalAccount {
    // 获取余额
    BigDecimal getBalance();

    // 取款
    void withdraw(BigDecimal amount);

    /**
     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
     * 如果初始余额为 10000 那么正确的结果应当是 0
     */
    static void demo(DecimalAccount account) {
        List<Thread> ts = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            ts.add(new Thread(() -> {
                account.withdraw(BigDecimal.TEN);
            }));
        }
        ts.forEach(Thread::start);
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        System.out.println(account.getBalance());
    }
}
```

### ABA 问题及解决 (==重点==)

- 如下程序所示，虽然 **在other方法中存在两个线程对共享变量进行了修改，但是修改之后又变成了原值**，**main线程对==修改过共享变量的过程==是不可见的，这种操作这对业务代码并无影响。**

  ```java
  public class Test1 {
  
      static AtomicReference<String> ref = new AtomicReference<>("A");
  
      public static void main(String[] args) {
          new Thread(() -> {
              String pre = ref.get();
              System.out.println("change");
              try {
                  other();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              Sleeper.sleep(1);
              //把ref中的A改为C
              System.out.println("change A->C " + ref.compareAndSet(pre, "C"));
          }).start();
      }
  
      static void other() throws InterruptedException {
          new Thread(() -> {
          	// 此时ref.get()为A,此时共享变量ref也是A,没有被改过, 此时CAS
          	// 可以修改成功, B
              System.out.println("change A->B " + ref.compareAndSet(ref.get(), "B"));
          }).start();
          Thread.sleep(500);
          new Thread(() -> {
          	// 同上, 修改为A
              System.out.println("change B->A " + ref.compareAndSet(ref.get(), "A"));
          }).start();
      }
  }
  
  ```

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227200916774.png)	

### AtomicStampedReference (加版本号解决ABA问题)

```java
public class Test1 {
    //指定版本号
    static AtomicStampedReference<String> ref = new AtomicStampedReference<>("A", 0);

    public static void main(String[] args) {
        new Thread(() -> {
            String pre = ref.getReference();
            //获得版本号
            int stamp = ref.getStamp(); // 此时的版本号还是第一次获取的
            System.out.println("change");
            try {
                other();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1
            System.out.println("change A->C stamp " + stamp + ref.compareAndSet(pre, "C", stamp, stamp + 1));
        }).start();
    }

    static void other() throws InterruptedException {
        new Thread(() -> {
            int stamp = ref.getStamp();
            System.out.println("change A->B stamp " + stamp + ref.compareAndSet(ref.getReference(), "B", stamp, stamp + 1));
        }).start();
        Thread.sleep(500);
        new Thread(() -> {
            int stamp = ref.getStamp();
            System.out.println("change B->A stamp " + stamp + ref.compareAndSet(ref.getReference(), "A", stamp, stamp + 1));
        }).start();
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227201334161.png)	

### AtomicMarkableReference (标记cas的共享变量是否被修改过)

==AtomicStampedReference== 可以给==原子引用==加上==版本号==，**追踪原子引用整个的变化过程**，如：A -> B -> A ->C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。

但是有时候，==并不关心引用变量更改了几次，只是单纯的关心是否更改过==，所以就有了==**AtomicMarkableReference**==

![1594803309714](https://img-blog.csdnimg.cn/img_convert/23026a8d2e27e7a4f474d15f0e3684bc.png)	

```java
public class TestABAAtomicMarkableReference {
    public static void main(String[] args) throws InterruptedException {
        GarbageBag bag = new GarbageBag("装满了垃圾");
        
        // 参数2 mark 可以看作一个标记，表示垃圾袋满了
      	//true 表示满的需要换垃圾袋，false表示空的不需要换垃圾袋
        AtomicMarkableReference<GarbageBag> ref = new AtomicMarkableReference<>(bag, true);
        log.debug("主线程 start...");
        
        GarbageBag prev = ref.getReference();
        log.debug(prev.toString());
        
        new Thread(() -> {
            log.debug("打扫卫生的线程 start...");
            bag.setDesc("空垃圾袋");
            while (!ref.compareAndSet(bag, bag, true, false)) {
            }
            log.debug(bag.toString());
        }).start();
        
        Thread.sleep(1000);
        log.debug("主线程想换一只新垃圾袋？");
        
        boolean success = ref.compareAndSet(prev, new GarbageBag("空垃圾袋"), true, false);
        log.debug("换了么？" + success);
        log.debug(ref.getReference().toString());
    }
}

class GarbageBag {
    String desc;

    public GarbageBag(String desc) {
        this.desc = desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    @Override
    public String toString() {
        return super.toString() + " " + desc;
    }
}
```

```java
23:37:59.877 [main] DEBUG c.TestABAAtomicMarkableReference - 主线程 start...
23:37:59.881 [main] DEBUG c.TestABAAtomicMarkableReference - 装满了垃圾
23:37:59.945 [Thread-0] DEBUG c.TestABAAtomicMarkableReference - 打扫卫生的线程 start...
23:37:59.945 [Thread-0] DEBUG c.TestABAAtomicMarkableReference - 空垃圾袋
23:38:00.949 [main] DEBUG c.TestABAAtomicMarkableReference - 主线程想换一只新垃圾袋？
23:38:00.949 [main] DEBUG c.TestABAAtomicMarkableReference - 换了么？false
23:38:00.949 [main] DEBUG c.TestABAAtomicMarkableReference - 空垃圾袋
```

举例2：

```java
public class Test1 {
    //指定版本号
    static AtomicMarkableReference<String> ref = new AtomicMarkableReference<>("A", true);

    public static void main(String[] args) {
        new Thread(() -> {
            String pre = ref.getReference();
            System.out.println("change");
            try {
                other();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1
            System.out.println("change A->C mark " + ref.compareAndSet(pre, "C", true, false));
        }).start();
    }

    static void other() throws InterruptedException {
        new Thread(() -> {
            System.out.println("change A->A mark " + ref.compareAndSet(ref.getReference(), "A", true, false));
        }).start();
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201227201642314.png)	

**AtomicStampedReference和AtomicMarkableReference两者的区别**

- AtomicStampedReference 需要我们传入 **==整型变量==** 作为==版本号==，来判定是否被更改过
- AtomicMarkableReference需要我们传入==**布尔变量**==作为==标记==，来判断是否被更改过

## 6、原子数组 (AtomicIntegerArray)

保证数组内的元素的==线程安全==

使用原子的方式更新数组里的某个元素

- **AtomicIntegerArray：整形数组原子类**
- **AtomicLongArray：长整形数组原子类**
- **AtomicReferenceArray：引用类型数组原子类**

上面三个类提供的方法几乎相同，所以我们这里以 ==AtomicIntegerArray== 为例子来介绍。实例代码

普通数组内元素, 多线程访问造成安全问题

```java
public class AtomicArrayTest {
    public static void main(String[] args) {
        demo(
                () -> new int[10],
                array -> array.length,
                (array, index) -> array[index]++,
                array -> System.out.println(Arrays.toString(array))
        );
    }

    /**
     * 参数1，提供数组、可以是线程不安全数组或线程安全数组
     * 参数2，获取数组长度的方法
     * 参数3，自增方法，回传 array, index
     * 参数4，打印数组的方法
     */
    // supplier 提供者 无中生有 ()->结果
    // function 函数 一个参数一个结果 (参数)->结果 , BiFunction (参数1,参数2)->结果
    // consumer 消费者 一个参数没结果 (参数)->void, BiConsumer (参数1,参数2)->void
    private static <T> void demo(Supplier<T> arraySupplier, Function<T, Integer> lengthFun,
                                 BiConsumer<T, Integer> putConsumer, Consumer<T> printConsumer) {
        List<Thread> ts = new ArrayList<>();
        T array = arraySupplier.get();
        int length = lengthFun.apply(array);

        for (int i = 0; i < length; i++) {
            // 创建10个线程, 每个线程对数组作 10000 次操作
            ts.add(new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    putConsumer.accept(array, j % length);
                }
            }));
        }

        ts.forEach(t -> t.start()); // 启动所有线程
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }); // 等所有线程结束

        printConsumer.accept(array);
    }
}
```

```java
[9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698]
```

- 使用==AtomicIntegerArray==来创建安全数组

  ```java
  demo(
          ()-> new AtomicIntegerArray(10),
          (array) -> array.length(),
          (array, index) -> array.getAndIncrement(index),
          array -> System.out.println(array)
  );
  
  demo(
          ()-> new AtomicIntegerArray(10),
          AtomicIntegerArray::length,
          AtomicIntegerArray::getAndIncrement,
          System.out::println
  );
  ```

  ```java
  [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]
  ```

## 7、字段更新器

保证==多线程==访问==同一个对象的成员变量==时, ==成员变量的线程安全性==。

- AtomicReferenceFieldUpdater —引用类型的属性
- AtomicIntegerFieldUpdater —整形的属性
- AtomicLongFieldUpdater —长整形的属性

注意：利用字段更新器，可以针对==对象的某个域（Field）进行原子操作==，只能==配合 volatile 修饰==的字段使用，否则会出现异常。

```java
Exception in thread "main" java.lang.IllegalArgumentException: Must be volatile type
```

- 例子

```java
public class AtomicFieldTest {
    public static void main(String[] args) {
        Student stu = new Student();
        // 获得原子更新器
      	// 泛型
      	// 参数1 持有属性的类 参数2 被更新的属性的类
      	// newUpdater中的参数：第三个为属性的名称
        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");
        // 期望的为null, 如果name属性没有被别的线程更改过, 默认就为null, 此时匹配, 就可以设置name为张三
        System.out.println(updater.compareAndSet(stu, null, "张三"));
       	System.out.println(stu);
        System.out.println(updater.compareAndSet(stu, stu.name, "王五"));
        System.out.println(stu);
    }
}

class Student {
    volatile String name;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
true
Student{name='张三'}
true
Student{name='王五'}
```

## 8、原子累加器 (LongAddr) (==重要==)

- ==LongAddr==
- LongAccumulator
- DoubleAddr
- DoubleAccumulator

##### `累加器性能比较 AtomicLong, LongAddr`

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("----AtomicLong----");
        for (int i = 0; i < 5; i++) {
            demo(() -> new AtomicLong(), adder -> adder.getAndIncrement());
        }

        System.out.println("----LongAdder----");
        for (int i = 0; i < 5; i++) {
            demo(() -> new LongAdder(), adder -> adder.increment());
        }
    }

    private static <T> void demo(Supplier<T> adderSupplier, Consumer<T> action) {
        T adder = adderSupplier.get();
        long start = System.nanoTime();
        List<Thread> ts = new ArrayList<>();
        // 4 个线程，每人累加 50 万
        for (int i = 0; i < 40; i++) {
            ts.add(new Thread(() -> {
                for (int j = 0; j < 500000; j++) {
                    action.accept(adder);
                }
            }));
        }
        ts.forEach(t -> t.start());
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        long end = System.nanoTime();
        System.out.println(adder + " cost:" + (end - start) / 1000_000);
    }
}
```

```java
----AtomicLong----
20000000 cost:646
20000000 cost:707
20000000 cost:689
20000000 cost:713
20000000 cost:657
----LongAdder----
20000000 cost:148
20000000 cost:139
20000000 cost:130
20000000 cost:122
20000000 cost:116
```

LongAddr

- **性能提升的原因很简单，就是在有竞争时，设置多个`累加单元`(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，`因此减少了 CAS 重试失败`，从而提高性能。**

AtomicLong

- **之前AtomicLong等都是在一个`共享资源变量`上进行竞争, `while(true)`循环进行CAS重试, 性能没有`LongAdder`高**

## 9、LongAdder原理 (了解)

#### 原理之伪共享

![img](https://img-blog.csdnimg.cn/img_convert/e1c53a0fb41d7d089e5ddcc71f1f2a0d.png)

- 缓存行伪共享得从`缓存`说起

- 缓存与内存的速度比较

  <img src="https://img-blog.csdnimg.cn/img_convert/9d3df3ad5311a92ecf235ccf78584ca3.png" alt="img" style="zoom:75%;" />	

  <img src="https://img-blog.csdnimg.cn/img_convert/b4d95b0315026ad343cda2dd2d2f3c2a.png" alt="img" style="zoom:75%;" />	

- 因为 `CPU 与 内存的速度差异很大`，需要靠`预读数据`至**缓存**来提升效率。而缓存以**缓存行**为单位，每个缓存行对应着一块内存，一般是 **64 byte**（8 个 long）**缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中**

- CPU 要保证数据的**一致性** (缓存一致性)，如果某个 CPU 核心**更改**了数据，其它 CPU 核心对应的整个缓存行必须**失效**

  ![img](https://img-blog.csdnimg.cn/img_convert/56de3a77bb6f96ba480f622083864c36.png)

因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：

- Core-0 要修改 Cell[0]
- Core-1 要修改 Cell[1]

无论谁修改成功，都会导致对方 Core 的缓存行失效，

- 比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效

- @sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的**前后各增加 128 字节大小的 padding**（空白），从而让 CPU 将对象预读至缓存时**占用不同的缓存行**，这样，不会造成对方缓存行的失效

  ![img](https://img-blog.csdnimg.cn/img_convert/4f0aefac3f7bfaece8703efa77e342fa.png)	

**累加主要调用以下方法**

```java
public void add(long x) {
       Cell[] as; long b, v; int m; Cell a;
       if ((as = cells) != null || !casBase(b = base, b + x)) {
           boolean uncontended = true;
           if (as == null || (m = as.length - 1) < 0 ||
               (a = as[getProbe() & m]) == null ||
               !(uncontended = a.cas(v = a.value, v + x)))
               longAccumulate(x, null, uncontended);
       }
   }
```

**累加流程图**

![img](https://img-blog.csdnimg.cn/img_convert/ce399f7bd72da53a22f6fbaba896dcc1.png)

## 10、Unsafe (`重点`)

- Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过`反射`获得

- 可以发现`AtomicInteger`以及其他的原子类, 底层都使用的是`Unsafe`类

  <img src="https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/image-20210708103614164.png" alt="在这里插入图片描述" style="zoom: 67%;" />		

- 使用底层的`Unsafe`实现原子操作

```java
public class Test {
    public static void main(String[] args) throws Exception {
        // 通过反射获得Unsafe对象
        Class unsafeClass = Unsafe.class;
        // 获得构造函数，Unsafe的构造函数为私有的
        Constructor constructor = unsafeClass.getDeclaredConstructor();
        // 设置为允许访问私有内容
        constructor.setAccessible(true);
        // 创建Unsafe对象
        Unsafe unsafe = (Unsafe) constructor.newInstance();

        // 创建Person对象
        Person person = new Person();
        // 获得其属性 name 的偏移量
        long nameOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField("name"));
        long ageOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField("age"));

        // 通过unsafe的CAS操作改变值
        unsafe.compareAndSwapObject(person, nameOffset, null, "guizy");
        unsafe.compareAndSwapInt(person, ageOffset, 0, 22);
        System.out.println(person);
    }
}

class Person {
    // 配合CAS操作，必须用volatile修饰
    volatile String name;
    volatile int age;
    
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



# 十一、共享模型之不可变

## 一、 不可变类设计 String

如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改

- **`类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性`**

- 如果一个对象在`不能够修改其内部状态（属性）`，那么它就是`线程安全`的，因为 **`不存在并发修改`**。

### 1、日期转换的问题

**问题提出**
下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
for (int i = 0; i < 10; i++) {
	 new Thread(() -> {
	 try {
	 	log.debug("{}", sdf.parse("1951-04-21"));
	 } catch (Exception e) {
	 	log.error("{}", e);
	 }
	 }).start();
}
```

```java
10:33:14.248 [Thread-3] ERROR c.DateFormatT1 - {}
java.lang.NumberFormatException: For input string: "E41"
	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2043)
	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)
	at java.lang.Double.parseDouble(Double.java:538)
	at java.text.DigitList.getDouble(DigitList.java:169)
	at java.text.DecimalFormat.parse(DecimalFormat.java:2089)
	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)
	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)
	at java.text.DateFormat.parse(DateFormat.java:364)
	at com.exampleone.demo.threadOne.bilibili.DateFormatT1.lambda$main$0(DateFormatT1.java:21)
	at java.lang.Thread.run(Thread.java:748)
10:33:14.248 [Thread-2] ERROR c.DateFormatT1 - {}
java.lang.NumberFormatException: multiple points
	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)
	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)
	at java.lang.Double.parseDouble(Double.java:538)
	at java.text.DigitList.getDouble(DigitList.java:169)
	at java.text.DecimalFormat.parse(DecimalFormat.java:2089)
	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)
	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)
	at java.text.DateFormat.parse(DateFormat.java:364)
	at com.exampleone.demo.threadOne.bilibili.DateFormatT1.lambda$main$0(DateFormatT1.java:21)
	at java.lang.Thread.run(Thread.java:748)
10:33:14.248 [Thread-1] ERROR c.DateFormatT1 - {}
java.lang.NumberFormatException: multiple points
	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)
	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)
	at java.lang.Double.parseDouble(Double.java:538)
	at java.text.DigitList.getDouble(DigitList.java:169)
	at java.text.DecimalFormat.parse(DecimalFormat.java:2089)
	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)
	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)
	at java.text.DateFormat.parse(DateFormat.java:364)
	at com.exampleone.demo.threadOne.bilibili.DateFormatT1.lambda$main$0(DateFormatT1.java:21)
	at java.lang.Thread.run(Thread.java:748)
10:33:14.248 [Thread-0] ERROR c.DateFormatT1 - {}
java.lang.NumberFormatException: For input string: "E41"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Long.parseLong(Long.java:589)
	at java.lang.Long.parseLong(Long.java:631)
	at java.text.DigitList.getLong(DigitList.java:195)
	at java.text.DecimalFormat.parse(DecimalFormat.java:2084)
	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)
	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)
	at java.text.DateFormat.parse(DateFormat.java:364)
	at com.exampleone.demo.threadOne.bilibili.DateFormatT1.lambda$main$0(DateFormatT1.java:21)
	at java.lang.Thread.run(Thread.java:748)
10:33:14.247 [Thread-9] DEBUG c.DateFormatT1 - Sat Apr 21 00:00:00 CST 1951
10:33:14.247 [Thread-4] DEBUG c.DateFormatT1 - Sat Apr 21 00:00:00 CST 1951
10:33:14.247 [Thread-7] DEBUG c.DateFormatT1 - Sat Apr 21 00:00:00 CST 1951
10:33:14.247 [Thread-8] DEBUG c.DateFormatT1 - Sat Apr 21 00:00:00 CST 1951
10:33:14.247 [Thread-5] DEBUG c.DateFormatT1 - Sat Apr 21 00:00:00 CST 1951
10:33:14.247 [Thread-6] DEBUG c.DateFormatT1 - Sat Apr 21 00:00:00 CST 1951
```

- **思路: 使用同步锁**
  这样虽能解决问题，但带来的是`性能`上的损失，并不算很好, 加锁耗性能

```java
@Slf4j(topic = "guizy.Test2")
public class Test2 {
    public static void main(String[] args) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                synchronized (sdf) {
                    try {
                        log.debug("{}", sdf.parse("2020-12-29"));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
}

21:24:31.989 guizy.Test2 [Thread-0] - Sat Apr 29 00:00:00 CST 2020
21:24:32.000 guizy.Test2 [Thread-9] - Sat Apr 29 00:00:00 CST 2020
21:24:32.000 guizy.Test2 [Thread-8] - Sat Apr 29 00:00:00 CST 2020
21:24:32.000 guizy.Test2 [Thread-7] - Sat Apr 29 00:00:00 CST 2020
21:24:32.001 guizy.Test2 [Thread-6] - Sat Apr 29 00:00:00 CST 2020
21:24:32.001 guizy.Test2 [Thread-5] - Sat Apr 29 00:00:00 CST 2020
21:24:32.001 guizy.Test2 [Thread-4] - Sat Apr 29 00:00:00 CST 2020
21:24:32.002 guizy.Test2 [Thread-3] - Sat Apr 29 00:00:00 CST 2020
21:24:32.002 guizy.Test2 [Thread-2] - Sat Apr 29 00:00:00 CST 2020
21:24:32.002 guizy.Test2 [Thread-1] - Sat Apr 29 00:00:00 CST 2020
```

- **思路 - 使用JD8中的 `不可变日期格式化类`**

**`如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊`**！这样的对象在Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：

```java
public class Test2 {
    public static void main(String[] args) {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                TemporalAccessor date = dtf.parse("2020-12-29");
                log.debug("{}", date);
            }).start();
        }
    }
}

21:38:54.842 guizy.Test2 [Thread-0] - {},ISO resolved to 2020-12-29
21:38:54.843 guizy.Test2 [Thread-1] - {},ISO resolved to 2020-12-29
21:38:54.842 guizy.Test2 [Thread-8] - {},ISO resolved to 2020-12-29
21:38:54.842 guizy.Test2 [Thread-9] - {},ISO resolved to 2020-12-29
21:38:54.842 guizy.Test2 [Thread-2] - {},ISO resolved to 2020-12-29
21:38:54.843 guizy.Test2 [Thread-4] - {},ISO resolved to 2020-12-29
21:38:54.843 guizy.Test2 [Thread-3] - {},ISO resolved to 2020-12-29
21:38:54.842 guizy.Test2 [Thread-7] - {},ISO resolved to 2020-12-29
21:38:54.842 guizy.Test2 [Thread-6] - {},ISO resolved to 2020-12-29
21:38:54.842 guizy.Test2 [Thread-5] - {},ISO resolved to 2020-12-29
```

可以看 DateTimeFormatter 的文档：

<img src="https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/image-20210708103614164.png" alt="image-20210708103614164" style="zoom:50%;" />		

- `不可变对象`，实际是另一种`避免竞争`的方式。

### 2、final 的使用

**Integer、Double、String、DateTimeFormatter以及基本类型包装类, 都是使用`final`来修饰的**

另一个大家更为熟悉的 `String 类`也是不可变的，以它为例，说明一下不可变类设计的要素

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];	// 在JDK9 使用了byte[] 数组
    /** Cache the hash code for the string */
    private int hash; // Default to 0
    // ...
}
```

- 发现该类、类中所有属性都是 `final` 的，属性用 final 修饰保证了该属性是`只读`的，不能修改，**`类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性`**。

##### 2.1、保护性拷贝

- 使用字符串时，也有一些跟修改相关的方法啊，比如`substring、replace` 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：

```java
public String substring(int beginIndex, int endIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex > value.length) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    int subLen = endIndex - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    // 上面是一些校验，下面才是真正的创建新的String对象
    return ((beginIndex == 0) && (endIndex == value.length)) ? this
            : new String(value, beginIndex, subLen);
}
```

发现其方法最后是调用`String 的构造方法创建了一个新字符串`，**再进入这个构造看看，是否对 final char[] value 做出了修改：结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制。**

- 这种通过创建副本对象来避免共享的手段称之为`【保护性拷贝（defensive copy）】`

```java
public String(char value[], int offset, int count) {
    if (offset < 0) {
        throw new StringIndexOutOfBoundsException(offset);
    }
    if (count <= 0) {
        if (count < 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        if (offset <= value.length) {
            this.value = "".value;
            return;
        }
    }
    // Note: offset or count might be near -1>>>1.
    if (offset > value.length - count) {
        throw new StringIndexOutOfBoundsException(offset + count);
    }
    // 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值
    this.value = Arrays.copyOfRange(value, offset, offset+count);
}
```

##### 2.2、final原理

 设置 final 变量的原理

- 理解了 `volatile 原理 (读写屏障)`，再对比 final 的实现就比较简单了

```java
public class TestFinal {
 final int a = 20; 
 }
```

字节码

```java
 0 aload_0
 1 invokespecial #1 <java/lang/Object.<init>>
 4 aload_0
 5 bipush 20
 7 putfield #2 <com/exampleone/demo/threadOne/bilibili/finalpackage/TestFinal.a>
   // <-- 写屏障
10 return
```

- 发现 final 变量的赋值也会通过 **putfield** 指令来完成，同样在这条指令之后也会加入`写屏障`，**保证在其它线程读到它的值时不会出现为 0 的情况。**

### 3、享元设计模式

简介定义英文名称：Flyweight pattern, **`重用数量有限的同一类对象`**。

- 结构型模式

享元模式的体现

1、在JDK中`Boolean，Byte，Short，Integer，Long，Character`等包装类提供了`valueOf`方法，例如 Long 的`valueOf`会缓存`-128~127`之间的 Long 对象，**在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象**

```java
public static Long valueOf(long l) {
    final int offset = 128;
    if (l >= -128 && l <= 127) { // will cache
        return LongCache.cache[(int)l + offset];
    }
    return new Long(l);
}
```

**注意：**

- Byte, Short, Long 缓存的范围都是-128-127
- Character 缓存的范围是 0-127
- Boolean 缓存了 TRUE 和 FALSE
- Integer的默认范围是 -128~127，最小值不能变，但最大值可以通过调整虚拟机参数 "-Djava.lang.Integer.IntegerCache.high "来改变

2、String 串池

3、BigDecimal, BigInteger

![img](https://img-blog.csdnimg.cn/20210125161655431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)



### 4、实现一个简单的连接池

例如：**一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。**

```java
/**
 * Description: 简易连接池
 */
public class Test2 {
    public static void main(String[] args) {
        /*使用连接池*/
        Pool pool = new Pool(2);
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                Connection conn = pool.borrow();
                try {
                    Thread.sleep(new Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                pool.free(conn);
            }).start();
        }
    }
}

class Pool {
    // 1. 连接池大小
    private final int poolSize;

    // 2. 连接对象数组
    private Connection[] connections;

    // 3. 连接状态数组: 0 表示空闲, 1 表示繁忙
    private AtomicIntegerArray states;

    // 4. 构造方法初始化
    public Pool(int poolSize) {
        this.poolSize = poolSize;
        this.connections = new Connection[poolSize];
        this.states = new AtomicIntegerArray(new int[poolSize]);//使用AtomicIntegerArray保证states的线程安全
        for (int i = 0; i < poolSize; i++) {
            connections[i] = new MockConnection("连接" + (i + 1));
        }
    }

    // 5. 借连接
    public Connection borrow() {
        while (true) {
            for (int i = 0; i < poolSize; i++) {
                // 获取空闲连接
                if (states.get(i) == 0) {
                    if (states.compareAndSet(i, 0, 1)) {//使用compareAndSet保证线程安全
                        log.debug("borrow {}", connections[i]);
                        return connections[i];
                    }
                }
            }
            // 如果没有空闲连接，当前线程进入等待, 如果不写这个synchronized,其他线程不会进行等待, 
            // 一直在上面while(true), 空转, 消耗cpu资源
            synchronized (this) {
                try {
                    log.debug("wait...");
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    // 6. 归还连接
    public void free(Connection conn) {
        for (int i = 0; i < poolSize; i++) {
            if (connections[i] == conn) {
                states.set(i, 0);
                synchronized (this) {
                    log.debug("free {}", conn);
                    this.notifyAll();
                }
                break;
            }
        }
    }
}

class MockConnection implements Connection {

    private String name;

    public MockConnection(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "MockConnection{" +
                "name='" + name + '\'' +
                '}';
    }
    
    // Connection 实现方法略
}
```

```java
17:14:49.467 [Thread-0] DEBUG c.Pool - borrow MockConnection{name='连接1'}
17:14:49.467 [Thread-1] DEBUG c.Pool - borrow MockConnection{name='连接2'}
17:14:49.467 [Thread-2] DEBUG c.Pool - wait...
17:14:49.477 [Thread-3] DEBUG c.Pool - wait...
17:14:49.480 [Thread-4] DEBUG c.Pool - wait...
17:14:49.486 [Thread-0] DEBUG c.Pool - free MockConnection{name='连接1'}
17:14:49.486 [Thread-4] DEBUG c.Pool - borrow MockConnection{name='连接1'}
17:14:49.488 [Thread-3] DEBUG c.Pool - wait...
17:14:49.489 [Thread-2] DEBUG c.Pool - wait...
17:14:50.055 [Thread-4] DEBUG c.Pool - free MockConnection{name='连接1'}
17:14:50.055 [Thread-3] DEBUG c.Pool - wait...
17:14:50.055 [Thread-2] DEBUG c.Pool - borrow MockConnection{name='连接1'}
17:14:50.456 [Thread-1] DEBUG c.Pool - free MockConnection{name='连接2'}
17:14:50.456 [Thread-3] DEBUG c.Pool - borrow MockConnection{name='连接2'}
17:14:50.597 [Thread-2] DEBUG c.Pool - free MockConnection{name='连接1'}
17:14:51.321 [Thread-3] DEBUG c.Pool - free MockConnection{name='连接2'}
```

![在这里插入图片描述](https://raw.githubusercontent.com/laowhite/images/master/blogImg/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70.png)	

​	

# 十二、共享模型之工具

## 1、线程池 (`重点`)

==**[Java并发编程：线程池的使用](https://www.cnblogs.com/dolphin0520/p/3932921.html)**==

> `池化技术`有很多, 比如`线程池`、`数据库连接池`、`HTTP连接池`等等都是对这个思想的应用。**`池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。`**

线程池提供了一种 **限制和管理资源**（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。

这里借用 **《Java 并发编程的艺术》** 提到的来说一下使用线程池的好处：

-  **`降低资源消耗。`通过重复利用已创建的线程降低线程创建和销毁造成的消耗。**(创建的线程,实际最后要和操作系统的线程做映射,很消耗资源）

-  **`提高响应速度。`当任务到达时，任务可以不需要等到线程创建就能立即执行**

-  **`提高线程的可管理性。`线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控**

### 1.1、 自定义一个简单的线程池

![img](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/11a58fc2d33881fcdf40e1980ca56cdb-20210708203653829.png)

- 阻塞队列中维护了由主线程（或者其他线程）所产生的的任务
- 主线程类似于**生产者**，产生任务并放入阻塞队列中
- 线程池类似于**消费者**，得到阻塞队列中已有的任务并执行

自定义线程池的实现步骤 :

- 步骤1：自定义拒绝策略接口
- 步骤2：自定义任务阻塞队列
- 步骤3：自定义线程池
- 步骤4：测试

```java
/**
 * Description: 自定义一个简单的线程池
 *
 * @author guizy
 * @date 2020/12/30 20:47
 */

@Slf4j(topic = "guizy.TestPool")
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1, new RejectPolicy<Runnable>() {
            @Override
            public void reject(BlockingQueue<Runnable> queue, Runnable task) {
                // 拒绝策略
                // 1、死等
                // queue.put(task);

                // 2、带超时等待
                queue.offer(task, 2000, TimeUnit.MILLISECONDS);

                // 3、让调用者放弃任务执行
                // log.debug("放弃-{}", task);

                // 4、让调用者抛弃异常
                // throw new RuntimeException("任务执行失败" + task);

                // 5、让调用者自己执行任务
                // task.run();
            }
        });
        // 创建5个任务
        for (int i = 0; i < 4; i++) {
            int j = i;
            threadPool.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    log.debug("{}", j);
                }
            });
        }
    }
}

@FunctionalInterface
interface RejectPolicy<T> {
    void reject(BlockingQueue<T> queue, T task);
}


/**
 * 线程池
 */
@Slf4j(topic = "guizy.TestPool")
class ThreadPool {

    // 阻塞任务队列
    private BlockingQueue<Runnable> taskQueue;

    // 线程集合
    private HashSet<Worker> workers = new HashSet<>();

    // 核心线程数
    private int coreSize;

    // 获取任务的超时时间
    private long timeout;

    private TimeUnit timeUnit;

    // 拒绝策略
    private RejectPolicy<Runnable> rejectPolicy;

    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity, RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    // 执行任务
    public void execute(Runnable task) {
        synchronized (workers) {
            // 当任务没有超过线程数, 说明当前worker线程可以消费这些任务, 不用将任务加入到阻塞队列中
            if (workers.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("新增 worker {}, {}", worker, task);
                workers.add(worker);
                worker.start();
            } else {
                // taskQueue.put(task); // 这一种死等
                // 拒绝策略
                // 1、死等
                // 2、带超时等待
                // 3、让调用者放弃任务执行
                // 4、让调用者抛弃异常
                // 5、让调用者自己执行任务
                taskQueue.tryPut(rejectPolicy, task);

            }
        }
    }

    class Worker extends Thread {
        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
            // 执行任务
            // 1): 当task不为空, 执行任务
            // 2): 当task执行完毕, 从阻塞队列中获取任务并执行
            //while (task != null || (task = taskQueue.take()) != null) {
            while (task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug("正在执行...{}", task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }

            // 将线程集合中的线程移除
            synchronized (workers) {
                log.debug("worker被移除 {}", this);
                workers.remove(this);
            }
        }
    }

}

/**
 * 用于存放任务的阻塞队列
 *
 * @param <T> Runnable, 任务抽象为Runnable
 */
@Slf4j(topic = "guizy.TestPool")
class BlockingQueue<T> {
    // 1、任务队列
    private Deque<T> queue = new ArrayDeque<>();

    // 2、锁
    private ReentrantLock lock = new ReentrantLock();

    // 3、生产者的条件变量 (当阻塞队列塞满任务的时候, 没有空间, 此时进入条件变量中等待)
    private Condition fullWaitSet = lock.newCondition();

    // 4、消费者的条件变量 (当没有任务可以消费的时候, 进入条件变量中等待)
    private Condition emptyWaitSet = lock.newCondition();

    // 5、阻塞队列的容量
    private int capacity;

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }


    // 从阻塞队列中获取任务, 如果没有任务, 会等待指定的时间
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
            // 将timeout统一转换为纳秒
            long nanos = unit.toNanos(timeout);
            while (queue.isEmpty()) {
                try {
                    // 表示超时, 无需等待, 直接返回null
                    if (nanos <= 0) {
                        return null;
                    }
                    // 返回值的时间(剩余时间) = 等待时间 - 经过时间 所以不存在虚假唤醒(时间还没等够就被唤醒,然后又从新等待相同时间)
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal(); // 唤醒生产者进行生产, 此时阻塞队列没有满
            return t;
        } finally {
            lock.unlock();
        }
    }

    // 从阻塞队列中获取任务, 如果没有任务,会一直等待
    public T take() {
        lock.lock();
        try {
            // 阻塞队列是否为空
            while (queue.isEmpty()) {
                // 进入消费者的条件变量中等待,此时没有任务供消费
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 阻塞队列不为空, 获取队列头部任务
            T t = queue.removeFirst();
            fullWaitSet.signal(); // 唤醒生产者进行生产, 此时阻塞队列没有满
            return t;
        } finally {
            lock.unlock();
        }
    }

    // 往阻塞队列中添加任务
    public void put(T task) {
        lock.lock();
        try {
            // 阻塞队列是否满了
            while (queue.size() == capacity) {
                try {
                    log.debug("等待进入阻塞队列...");
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            queue.addLast(task);
            log.debug("加入任务阻塞队列 {}", task);
            emptyWaitSet.signal(); // 此时阻塞队列中有任务了, 唤醒消费者进行消费任务
        } finally {
            lock.unlock();
        }
    }

    // 往阻塞队列中添加任务(带超时)
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capacity) {
                try {
                    if (nanos <= 0) {
                        return false;
                    }
                    log.debug("等待进入阻塞队列 {}...", task);
                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("加入任务阻塞队列 {}", task);
            queue.addLast(task);
            emptyWaitSet.signal(); // 此时阻塞队列中有任务了, 唤醒消费者进行消费任务
            return true;
        } finally {
            lock.unlock();
        }
    }

    // 获取队列大小
    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            // 判断队列是否满
            if (queue.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                // 有空闲
                log.debug("加入任务队列 {}", task);
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}
```

实现了一个简单的线程池

阻塞队列BlockingQueue用于暂存来不及被线程执行的任务

- 也可以说是平衡生产者和消费者执行速度上的差异

- 里面的获取任务和放入任务用到了 生产者消费者模式

线程池中对线程Thread进行了再次的封装，封装为了Worker

- 在调用 **任务对象 (Runnable、Callable)** 的run方法时，线程会去执行该任务，执行完毕后还会到**阻塞队列中获取新任务来执行**
  线程池中执行任务的主要方法为execute方法

执行时要判断正在执行的线程数是**否大于了线程池容量**

### 1.2、 ThreadPoolExecutor

#### 1.2.1、**线程池的继承关系**

<img src="https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/image-20210708174030140-20210708203654639.png" alt="image-20210708174030140" style="zoom:50%;" />	



#### 1.2.2、**Executor 框架结构 : 主要由三大部分组成**

**任务类** (`Runnable` /`Callable`)

- 执行任务需要实现的 **`Runnable 接口` 或 `Callable接口`**。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。

**任务的执行** (`Executor`)

- 如上图所示，包括任务执行机制的核心接口 **Executor** ，以及继承自 `Executor` 接口的 ExecutorService 接口。**`ThreadPoolExecutor` 和 `ScheduledThreadPoolExecutor` 这两个关键类实现了 ExecutorService 接口。**


- 这里有很多底层的类关系，但是，实际上我们需要更多关注的是 **ThreadPoolExecutor** 这个类，它在我们实际使用线程池的过程中，使用频率非常高。

**异步计算的结果** (`Future`)

**`Future 接口`** 以及 Future接口的 **`实现类 FutureTask 类`** 都可以代表异步计算的结果。

当把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 `submit()` 方法时会返回一个 `FutureTask`对象）

- Futrue和join方法类似, `futrue的get方法`需要等待线程执行完毕,才可以获取的线程的执行结果。也称之为`保护性暂停`

  ![在这里插入图片描述](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70-20210708174445171-20210708203655032.png)	

#### 1.2.3、**Executor 框架的使用示意图**

![Executor 框架的使用示意图](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/format,png-20210708203655651.png)	

1. 主线程首先要创建实现 **Runnable** 或者 **Callable** 接口的任务对象。
2. 把创建完成的实现 **Runnable/Callable接口的对象** 直接交给 **ExecutorService** 执行:

- `ExecutorService.execute（Runnable command）`
- `ExecutorService.submit（Runnable task）`
- `ExecutorService.submit（Callable <T> task）`

3. 如果执行 ExecutorService.submit（…），ExecutorService 将返回一个`实现Future接口的对象`

> 刚刚也提到过了执行 `execute()`方法和 `submit()`方法的区别，`submit()`会返回一个 `FutureTask` 对象

4. 最后，**主线程可以执行 FutureTask.get()方法来等待任务执行完成**。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行

### 1.3、 线程池状态

- **ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量**

```java
// 线程池状态
// runState is stored in the high-order bits
// RUNNING 高3位为111
private static final int RUNNING    = -1 << COUNT_BITS;

// SHUTDOWN 高3位为000
private static final int SHUTDOWN   =  0 << COUNT_BITS;

// 高3位 001
private static final int STOP       =  1 << COUNT_BITS;

// 高3位 010
private static final int TIDYING    =  2 << COUNT_BITS;

// 高3位 011
private static final int TERMINATED =  3 << COUNT_BITS;
```

| 状态名     | 高3位 | 接收新任务 | 处理阻塞队列任务 | 说明                                       |
| ---------- | ----- | ---------- | ---------------- | ------------------------------------------ |
| RUNNING    | 111   | Y          | Y                |                                            |
| SHUTDOWN   | 000   | N          | Y                | 不会接收新任务，但会处理阻塞队列剩余任务   |
| STOP       | 001   | N          | N                | 会中断正在执行的任务，并抛弃阻塞队列任务   |
| TIDYING    | 010   | -          | -                | 任务全执行完毕，活动线程为 0 即将进入 终结 |
| TERMINATED | 011   | -          | -                | 终结状态                                   |

- 从数字上比较(第一位是符号位)，`TERMINATED > TIDYING > STOP > SHUTDOWN > RUNNING`

线程池状态和线程池中线程的数量 **由一个原子整型ctl来共同表示**

> 使用一个数来表示两个值的主要原因是：**可以通过一次CAS同时更改两个属性的值**

```java
// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 并不是所有平台的int都是32位。
// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量
// 高3位为0，剩余位数全为1
private static final int COUNT_BITS = Integer.SIZE - 3;

// 2^COUNT_BITS次方，表示可以保存的最大线程数
// CAPACITY 的高3位为 0
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
```

获取线程池状态、线程数量以及合并两个值的操作

```java
// Packing and unpacking ctl
// 获取运行状态
// 该操作会让除高3位以外的数全部变为0
private static int runStateOf(int c)     { return c & ~CAPACITY; }

// 获取运行线程数
// 该操作会让高3位为0
private static int workerCountOf(int c)  { return c & CAPACITY; }

// 计算ctl新值
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值

```java
// c 为旧值， ctlOf 返回结果为新值
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));

// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

#### 线程池的属性

```java
// 工作线程，内部封装了Thread
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable {
    ...
}

// 阻塞队列，用于存放来不及被核心线程执行的任务
private final BlockingQueue<Runnable> workQueue;

// 锁
private final ReentrantLock mainLock = new ReentrantLock();

//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）
private final HashSet<Worker> workers = new HashSet<Worker>();
```

![在这里插入图片描述](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70-20210708195412455-20210708203656011.png)

### 1.4、 构造方法及参数

- **ThreadPoolExecutor最全的构造方法**

- 也是构造自定义线程池的方法

  <img src="https://raw.githubusercontent.com/laowhite/images/master/blogImg/image-20210708200211615.png" alt="image-20210708200211615" style="zoom:50%;" />`

```JAVA
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

**参数解释**

- **corePoolSize**：核心线程数
- **maximumPoolSize**：最大线程数
  - maximumPoolSize - corePoolSize = 救急线程数
  - `注意 :` 救急线程在**没有空闲的核心线程**和**任务队列满了**的情况才使用救急线程

- **keepAliveTime**：救急线程空闲时的最大生存时间 (核心线程可以一直运行)
- **unit**：时间单位 (针对救急线程)
- **workQueue**：阻塞队列（存放任务）
  - 有界阻塞队列 ArrayBlockingQueue
  - 无界阻塞队列 LinkedBlockingQueue
  - 最多只有一个同步元素的 SynchronousQueue
  - 优先队列 PriorityBlockingQueue
- **threadFactory**：线程工厂（给线程取名字）
- **handler**：拒绝策略



**工作方式**

![img](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70-20210708200732136-20210708203756664.png)			

当一个任务传给线程池以后，可能有以下几种可能

-  将任务分配给一个核心线程来执行
- 核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行
- 阻塞队列满了，使用救急线程来执行任务
- 救急线程用完以后，超过生存时间（keepAliveTime）后会被释放
- 任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略



#### 拒绝策略

[线程池拒绝策略分别使用在什么场景](https://blog.csdn.net/weixin_48502062/article/details/106682658)

如果线程到达 maximumPoolSize 仍然有新任务这时会执行**拒绝策略**。拒绝策略 jdk 提供了 4 种实现

<img src="https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/9c9e1f25573ca20f44ac080a5f6540c5.png" alt="img" style="zoom:75%;" />

口诀法：**拒中丢老调**（线程池拒绝策略：中止策略、丢弃策略、弃老策略、调用者运行策略）

简单回答：

1. 中止策略：无特殊场景。
2. 丢弃策略：无关紧要的任务（博客阅读量）。
3. 弃老策略：发布消息。
4. 调用者运行策略：不允许失败场景（对性能要求不高、并发量较小）。

`AbortPolicy 中止策略`：丢弃任务并抛出RejectedExecutionException异常。**这是默认策略**

> 这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。
>
> **功能**：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程.
>
> **使用场景**：这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。

`DiscardPolicy 丢弃策略`：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。

> 使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。
>
> **功能**：直接静悄悄的丢弃这个任务，不触发任何动作。
> 使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。

`DiscardOldestPolicy 弃老策略`：丢弃队列最前面的任务，然后重新提交被拒绝的任务。

>  此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。
>
> **功能**：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行
>
> **使用场景：**这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。

`CallerRunsPolicy 调用者运行策略`：由调用线程处理该任务。

>  功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。
>
> **使用场景**：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。

> 1. 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。
> 2. 当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。
> 3. 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。
> 4. 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 下面的前`4 种实现`，其它著名框架也提供了实现
>    1. ThreadPoolExecutor.AbortPolicy让调用者抛出 RejectedExecutionException 异常，这是**默认策略**
>    2. ThreadPoolExecutor.CallerRunsPolicy 让调用者运行任务
>    3. ThreadPoolExecutor.DiscardPolicy 放弃本次任务
>    4. ThreadPoolExecutor.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之
>    5. Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题
>    6. Netty 的实现，是创建一个新线程来执行任务
>    7. ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略
>    8. PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略
> 5. 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。

```java
public class Demo1 {

    static AtomicInteger threadId = new AtomicInteger(0);

    public static void main(String[] args) {
        // 手动创建线程池
        // 创建有界阻塞队列, 用来存放任务对象
        ArrayBlockingQueue<Runnable> runnable = new ArrayBlockingQueue<>(10);
        // 创建线程工厂: 主要给线程起名字
        ThreadFactory threadFactory = new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "guizy_thread" + threadId.getAndIncrement());
            }
        };

        // 手动创建线程池
        // 拒绝策略采用默认策略
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 7, 10, TimeUnit.SECONDS, runnable, threadFactory);
		
		// 执行20个任务
        for (int i = 0; i < 20; i++) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread());
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }
}
```

![在这里插入图片描述](https://qwoss.oss-cn-hangzhou.aliyuncs.com/Img/20210103001214433.png)

根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池

### 1.5、 newFixedThreadPool

这个是`Executors类`提供的工厂方法来创建线程池！`Executors` 是Executor 框架的工具类！

```java
public class TestFixedThreadPool {
   public static void main(String[] args) {
      // 自定义线程工厂
      ThreadFactory factory = new ThreadFactory() {
         AtomicInteger atomicInteger = new AtomicInteger(1);

         @Override
         public Thread newThread(Runnable r) {
            return new Thread(r, "myThread_" + atomicInteger.getAndIncrement());
         }
      };

      // 创建核心线程数量为2的线程池
      // 通过 ThreadFactory可以给线程添加名字

      ExecutorService executorService = Executors.newFixedThreadPool(2, factory);

      // 任务
      Runnable runnable = new Runnable() {
         @Override
         public void run() {
            System.out.println(Thread.currentThread().getName());
            System.out.println("this is fixedThreadPool");
         }
      };
      
      executorService.execute(runnable);
   }
}
```

固定大小的线程池可以传入两个参数

- 核心线程数：**nThreads**
- 线程工厂：**threadFactory**

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>(),
                                      threadFactory);
    }
```

**特点**

1. 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间
2. `阻塞队列是无界的，可以放任意数量的任务`
3. **适用于任务量已知，相对耗时的任务**

### 1.6、 newCachedThreadPool

```java
ExecutorService executorService = Executors.newCachedThreadPool();
```

**内部构造方法**

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

- **没有核心线程**，最大线程数为`Integer.MAX_VALUE`，**所有创建的线程都是救急线程 (`可以无限创建`)**，空闲时生存时间为60秒
- 阻塞队列使用的是**SynchronousQueue**

> SynchronousQueue是一种特殊的队列
>
> -  **没有容量**，没有线程来取是放不进去的
>
> - 只有当线程取任务时，才会将任务放入该阻塞队列中

- **整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况**

### 1.7、newSingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

**使用场景：**

1. **希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。** 任务执行完毕，这唯一的线程也不会被释放。

2. 区别：
   1. `和自己创建单线程执行任务的区别`：**自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而newSingleThreadExecutor线程池还会新建一个线程，保证池的正常工作**

   2. Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改
      *FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用* *ThreadPoolExecutor 中特有的方法*

   3. 和==Executors.newFixedThreadPool(1)== 初始时为1时的区别：Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改

      

#### Executors 返回线程池对象的弊端如下 (`重点`)

`注意:` Executors 返回线程池对象的弊端如下：

- **FixedThreadPool 和 SingleThreadExecutor ： `允许请求的队列长度为 Integer.MAX_VALUE` (无界阻塞队列),可能堆积大量的请求，从而导致 OOM。**
- **CachedThreadPool 和 ScheduledThreadPool ： `允许创建的线程数量为 Integer.MAX_VALUE` ，可能会创建大量线程，从而导致 OOM。**

> **建议使用`ThreadPoolExecutor`来创建线程**

避免上面的措施 : **`使用有界队列，控制线程创建数量。`**

除了避免 OOM 的原因之外，不推荐使用 `Executors`提供的两种快捷的线程池的原因还有：

1. **实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。**
2. 我们应该显示地给我们的线程池命名，这样有助于我们定位问题。

分析案例：

```java
/**
 * @Description: 线程池案例分析
 */
@Slf4j(topic = "c.FixedPool")
public class FixedPool {

    public static void main(String[] args) {
        ThreadPoolExecutor pool2 = new ThreadPoolExecutor(5, 8, 2,
                TimeUnit.SECONDS,  new LinkedBlockingQueue<>(2));
        for (int i = 0; i < 20; i++) {
            MyTask2 myTask2 = new MyTask2(i);
            try {
                pool2.execute(myTask2);
            } catch (Exception e) {
                log.error("{} 被拒绝了:{}",i,e.getMessage());
            }
            log.info(i+" 线程池中线程数目："+pool2.getPoolSize()+"，队列中等待执行的任务数目："+
                    pool2.getQueue().size()+"，已执行玩别的任务数目："+pool2.getCompletedTaskCount());
        }
        pool2.shutdown();
    }
}

@Slf4j(topic = "c.MyTask")
class MyTask2 implements Runnable {
    private int taskNum;

    public MyTask2(int num) {
        this.taskNum = num;
    }

    @Override
    public void run() {
        log.info("正在执行task "+taskNum);
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info("task "+taskNum+"执行完毕");
    }
}
```

```java
00:43:53.456 [pool-1-thread-1] INFO c.MyTask - 正在执行task 0
00:43:53.456 [main] INFO c.FixedPool - task 0 线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
00:43:53.464 [main] INFO c.FixedPool - task 1 线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
00:43:53.465 [pool-1-thread-2] INFO c.MyTask - 正在执行task 1
00:43:53.467 [main] INFO c.FixedPool - task 2 线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
00:43:53.468 [pool-1-thread-3] INFO c.MyTask - 正在执行task 2
00:43:53.468 [main] INFO c.FixedPool - task 3 线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
00:43:53.469 [pool-1-thread-4] INFO c.MyTask - 正在执行task 3
00:43:53.470 [main] INFO c.FixedPool - task 4 线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
00:43:53.471 [main] INFO c.FixedPool - task 5 线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0
00:43:53.471 [main] INFO c.FixedPool - task 6 线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:53.471 [pool-1-thread-5] INFO c.MyTask - 正在执行task 4
00:43:53.472 [main] INFO c.FixedPool - task 7 线程池中线程数目：6，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:53.472 [pool-1-thread-6] INFO c.MyTask - 正在执行task 7
00:43:53.474 [main] INFO c.FixedPool - task 8 线程池中线程数目：7，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:53.475 [pool-1-thread-7] INFO c.MyTask - 正在执行task 8
00:43:53.475 [main] INFO c.FixedPool - task 9 线程池中线程数目：8，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:53.475 [pool-1-thread-8] INFO c.MyTask - 正在执行task 9
00:43:53.476 [main] ERROR c.FixedPool - task 10 被拒绝了
00:43:53.478 [main] INFO c.FixedPool - task 10 线程池中线程数目：8，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:53.478 [main] ERROR c.FixedPool - task 11 被拒绝了
00:43:53.478 [main] INFO c.FixedPool - task 11 线程池中线程数目：8，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:53.478 [main] ERROR c.FixedPool - task 12 被拒绝了
00:43:53.478 [main] INFO c.FixedPool - task 12 线程池中线程数目：8，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:53.479 [main] ERROR c.FixedPool - task 13 被拒绝了
00:43:53.479 [main] INFO c.FixedPool - task 13 线程池中线程数目：8，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:53.479 [main] ERROR c.FixedPool - task 14 被拒绝了
00:43:53.479 [main] INFO c.FixedPool - task 14 线程池中线程数目：8，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
00:43:57.460 [pool-1-thread-1] INFO c.MyTask - task 0执行完毕
00:43:57.462 [pool-1-thread-1] INFO c.MyTask - 正在执行task 5
00:43:57.470 [pool-1-thread-2] INFO c.MyTask - task 1执行完毕
00:43:57.470 [pool-1-thread-2] INFO c.MyTask - 正在执行task 6
00:43:57.471 [pool-1-thread-4] INFO c.MyTask - task 3执行完毕
00:43:57.471 [pool-1-thread-3] INFO c.MyTask - task 2执行完毕
00:43:57.472 [pool-1-thread-5] INFO c.MyTask - task 4执行完毕
00:43:57.473 [pool-1-thread-6] INFO c.MyTask - task 7执行完毕
00:43:57.478 [pool-1-thread-7] INFO c.MyTask - task 8执行完毕
00:43:57.478 [pool-1-thread-8] INFO c.MyTask - task 9执行完毕
00:44:01.466 [pool-1-thread-1] INFO c.MyTask - task 5执行完毕
00:44:01.471 [pool-1-thread-2] INFO c.MyTask - task 6执行完毕
```

　　从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。创建新的线程比队列中的先执行，队列中的5.6最后执行。当线程数大于==maximumPoolSize==+队列大小，那么会触发拒绝策略 +队列的大小。会触发拒绝策略。

### 1.8、 执行/提交任务 execute/submit

```java
// 执行任务
void execute(Runnable command);

// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成
<T> Future<T> submit(Callable<T> task);

// 提交 tasks 中所有任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
 
// 提交 tasks 中所有任务，带超时时间
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit) throws InterruptedException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
<T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
<T> T invokeAny(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
```

#### execute()方法











